# don't put duplicate lines or lines starting with space in the history.
# See bash(1) for more options
HISTCONTROL=ignoreboth:erasedups

# append to the history file, don't overwrite it
shopt -s histappend

# Give option to modify history commands before executing
shopt -s histverify

# for setting history length see HISTSIZE and HISTFILESIZE in bash(1)
HISTSIZE=1000
HISTFILESIZE=10000

# Add timestamps to history file
HISTTIMEFORMAT='%F %T '

# Don't log calls to the boring commands
HISTIGNORE='ls:bg:fg:history'

# check the window size after each command and, if necessary,
# update the values of LINES and COLUMNS.
shopt -s checkwinsize

# If set, the pattern "**" used in a pathname expansion context will
# match all files and zero or more directories and subdirectories.
#shopt -s globstar

# make less more friendly for non-text input files, see lesspipe(1)
[ -x /usr/bin/lesspipe ] && eval "$(SHELL=/bin/sh lesspipe)"

# Make bash and all readline programs operate in vi mode
set -o vi

# Shell Options
shopt -s cdspell # Automatically fix 'cd' spelling mistakes
shopt -s autocd # Using 'cd' is so passe
shopt -s cmdhist # Combine multi-line entries into one history line

# TODO Going to comment the below out as an experiment, just in case
# # set variable identifying the chroot you work in (used in the prompt below)
# if [ -z "$debian_chroot" ] && [ -r /etc/debian_chroot ]; then
#     debian_chroot=$(cat /etc/debian_chroot)
# fi
#
# # set a fancy prompt (non-color, unless we know we "want" color)
# case "$TERM" in
#     xterm-color) color_prompt=yes;;
# esac
#
#
# # If this is an xterm set the title to user@host:dir
# case "$TERM" in
# xterm*|rxvt*)
#     PS1="\[\e]0;${debian_chroot:+($debian_chroot)}\u@\h: \w\a\]$PS1"
#     ;;
# *)
#     ;;
# esac

# uncomment for a colored prompt, if the terminal has the capability; turned
# off by default to not distract the user: the focus in a terminal window
# should be on the output of commands, not on the prompt
# force_color_prompt=yes
#
# if [ -n "$force_color_prompt" ]; then
#     if [ -x /usr/bin/tput ] && tput setaf 1 >&/dev/null; then
#     # We have color support; assume it's compliant with Ecma-48
#     # (ISO/IEC-6429). (Lack of such support is extremely rare, and such
#     # a case would tend to support setf rather than setaf.)
#     color_prompt='yes'
#     else
#     color_prompt='no'
#     fi
# fi

# if [ "$color_prompt" = 'yes' ]; then
#     PS1='${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ '
# else
#     PS1='${debian_chroot:+($debian_chroot)}\u@\h:\w\$ '
# fi
# unset color_prompt force_color_prompt

# On changing directory, ls and git fetch in background if git directory
function __prompt_command() {
    local LAST_EXIT_CODE="${?}"

    local RESET_COLOR='\[\e[0m\]'
    local RED='\[\e[0;31m\]'
    local GREEN='\[\e[0;32m\]'
    local PURPLE='\[\e[0;35m\]'
    local BRIGHT_RED='\[\e[1;31m\]'
    local BRIGHT_GREEN='\[\e[1;32m\]'
    local BRIGHT_YELLOW='\[\e[1;33m\]'
    local BRIGHT_BLUE='\[\e[1;34m\]'
    local BRIGHT_PURPLE='\[\e[1;35m\]'
    local DARK_GREY='\[\e[1;30m\]'
    local BLACK_FORE_LIGHT_GREY_BACK='\[\e[48;5;0;38;5;254m\]'
    local INVERTED_COLOR='\[\e[7m\]'

    if [ ${LAST_EXIT_CODE} == 0 ]; then
        local NAME_COLOR="${BRIGHT_PURPLE}"
    else
        local NAME_COLOR="${BRIGHT_RED}"
    fi


    # Bold move: don't show user/hostname
    PS1="${RESET_COLOR}${DARK_GREY}[$(date +%H:%M:%S)] ${NAME_COLOR}\w${RESET_COLOR} "

    # # If directory is a Git repo, add the branch name
    # local git_addition=""
    # local branch_name="$(git rev-parse --abbrev-ref HEAD 2>/dev/null)"
    # local get_branch_retcode="${?}"
    # local commit_hash="$(git rev-parse --short HEAD 2>/dev/null)"
    # local get_commit_retcode="${?}"
    # if [ ${get_branch_retcode} -eq 0 ] && [ -n "${branch_name}" ] && [ "${branch_name}" != "HEAD" ]; then
    #     git_addition="${branch_name}"
    # elif [ ${get_commit_retcode} -eq 0 ] && [ -n "${commit_hash}" ]; then
    #     git_addition="${commit_hash}"
    # fi
    # if [ -n "${git_addition}" ]; then
    #     PS1+="${BRIGHT_YELLOW}(${git_addition})${RESET_COLOR} "
    # fi

    PS1+="$(bash ~/.bash_utils/git-prompt-addition.sh)"

    if [[ ${__new_wd:=$PWD} != $PWD ]]; then
        ls
        [[ -d ".git" ]] && command -v git >/dev/null 2>&1 && ( [ -n "$(git fetch --prune 2>&1)" ] && echo -e "\n\e[1;32mGIT FETCHED THINGS\e[0m" & )
    fi
    __new_wd=$PWD
}
PROMPT_COMMAND=__prompt_command


export EDITOR="vim"

# Make completion better
bind "set completion-ignore-case on"
bind "set show-all-if-ambiguous on"

# Set all additions to PATH
PATH_ADDITIONS[0]=$HOME/.rvm/bin    # RVM to PATH for scripting
for PATH_TO_ADD in "${PATH_ADDITIONS[@]}"; do
    PATH="$PATH:$PATH_TO_ADD"
done

# Source RVM scripts
if [[ -s "$HOME/.rvm/scripts/rvm" ]] ; then
    source ~/.rvm/scripts/rvm
fi

# Custom bash additions
if [ -f ~/.bash_additions ]; then
  source ~/.bash_additions
fi

# Alias definitions
if [ -f ~/.bash_aliases ]; then
    source ~/.bash_aliases
fi

# Mac-specific additions
if [ -f ~/.bash_mac ]; then
    source ~/.bash_mac
fi

# Machine-specific additions
if [ -f ~/.bash_local ]; then
    source ~/.bash_local
fi

# enable programmable completion features (you don't need to enable
# this, if it's already enabled in /etc/bash.bashrc and /etc/profile
# sources /etc/bash.bashrc).
if [ -f /etc/bash_completion ] && ! shopt -oq posix; then
    source /etc/bash_completion
fi
