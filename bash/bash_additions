# Make bash and all readline programs operate in vi mode
set -o vi

# Shell Options
shopt -s cdspell # Automatically fix 'cd' spelling mistakes
shopt -s autocd # Using 'cd' is so passe
shopt -s cmdhist # Combine multi-line entries into one history line

# TODO Going to comment the below out as an experiment, just in case
# # set variable identifying the chroot you work in (used in the prompt below)
# if [ -z "$debian_chroot" ] && [ -r /etc/debian_chroot ]; then
#     debian_chroot=$(cat /etc/debian_chroot)
# fi
#
# # set a fancy prompt (non-color, unless we know we "want" color)
# case "$TERM" in
#     xterm-color) color_prompt=yes;;
# esac
#
#
# # If this is an xterm set the title to user@host:dir
# case "$TERM" in
# xterm*|rxvt*)
#     PS1="\[\e]0;${debian_chroot:+($debian_chroot)}\u@\h: \w\a\]$PS1"
#     ;;
# *)
#     ;;
# esac

# uncomment for a colored prompt, if the terminal has the capability; turned
# off by default to not distract the user: the focus in a terminal window
# should be on the output of commands, not on the prompt
# force_color_prompt=yes
#
# if [ -n "$force_color_prompt" ]; then
#     if [ -x /usr/bin/tput ] && tput setaf 1 >&/dev/null; then
# 	# We have color support; assume it's compliant with Ecma-48
# 	# (ISO/IEC-6429). (Lack of such support is extremely rare, and such
# 	# a case would tend to support setf rather than setaf.)
# 	color_prompt='yes'
#     else
# 	color_prompt='no'
#     fi
# fi

# if [ "$color_prompt" = 'yes' ]; then
#     PS1='${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ '
# else
#     PS1='${debian_chroot:+($debian_chroot)}\u@\h:\w\$ '
# fi
# unset color_prompt force_color_prompt

# On changing directory, ls and git fetch in background if git directory
function __prompt_command() {
    local LAST_EXIT_CODE="${?}"

    local RESET_COLOR='\[\e[0m\]'
    local RED='\[\e[0;31m\]'
    local GREEN='\[\e[0;32m\]'
    local PURPLE='\[\e[0;35m\]'
    local BRIGHT_RED='\[\e[1;31m\]'
    local BRIGHT_GREEN='\[\e[1;32m\]'
    local BRIGHT_YELLOW='\[\e[1;33m\]'
    local BRIGHT_BLUE='\[\e[1;34m\]'
    local BRIGHT_PURPLE='\[\e[1;35m\]'

    if [ ${LAST_EXIT_CODE} == 0 ]; then
        local NAME_COLOR="${BRIGHT_PURPLE}"
    else
        local NAME_COLOR="${BRIGHT_RED}"
    fi
    
    # Bold move: don't show user/hostname
    PS1="${RESET_COLOR}${NAME_COLOR}> \w${RESET_COLOR} "

    if [[ ${__new_wd:=$PWD} != $PWD ]]; then 
        ls
        [[ -d ".git" ]] && command -v git >/dev/null 2>&1 && ( [ -n "$(git fetch --prune 2>&1)" ] && echo -e "\n\e[1;35mGIT FETCHED THINGS\e[0m" & )
    fi
    __new_wd=$PWD
}
PROMPT_COMMAND=__prompt_command


export EDITOR="vim"

# Make completion better
bind "set completion-ignore-case on"
bind "set show-all-if-ambiguous on"

# Set all additions to PATH
PATH_ADDITIONS[0]=$HOME/.rvm/bin	# RVM to PATH for scripting
for PATH_TO_ADD in "${PATH_ADDITIONS[@]}"; do
	PATH="$PATH:$PATH_TO_ADD"
done

# Source RVM scripts
if [[ -s "$HOME/.rvm/scripts/rvm" ]] ; then
    source ~/.rvm/scripts/rvm
fi

