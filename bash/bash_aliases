#!/usr/bin/env bash
# Shebang for syntax highlight

# Better diff (Mac only)
alias diff="colordiff --ignore-space-change -u"

# Datetime
alias today='date +%F'
alias now='date +%F_%H-%M-%S'

# Allow editing Mac crontab with Vim per:
# http://superuser.com/questions/359580/error-adding-cronjobs-in-mac-os-x-lion
alias crontab="VIM_CRONTAB=true crontab"

# ls conveniences
function ls() { # Display an empty line for empty directories
    # Use `command ls` to avoid accidentally fork-bombing myself. Oops...
    if [[ $(command ls "${@}" | wc -l) -eq 0 ]]; then
        echo 
    else
        command ls -G "$@"
    fi
}
alias ll='ls -Alhtr'
alias llt='ll -t' # Sort by date last modified
alias la='ls -A'
alias l='ls'

alias cat="bat"

# du should always be human readable
alias du='du -h'

# Overwrite cd to jump up multiple levels with 'cd <# dir>..' syntax
function cd() {
    # If string isn't long enough, use builtin cd anyways
    if [[ ${#1} -lt 3 ]]; then
        builtin cd "$@"
    else
        # Check if string is in '<number>..' form
        if [[ "${1:(-2)}" == ".." ]] && [[ -n "${1%..}" ]] && [[ "${1%..}" =~ ^[0-9]+$ ]]; then
            REPEAT_TIMES="${1%..}"
            if [ "${REPEAT_TIMES}" -le 0 ]; then
                echo "Cannot do ${REPEAT_TIMES} cd's"
                return 1
            fi

            CD_STR=""
            while read; do
                CD_STR="../$CD_STR"
            done < <(seq 1 "${REPEAT_TIMES}")
            cd "$CD_STR"
        else
            builtin cd "$@"
        fi
    fi
}


# Easily copy the contents of one or more file
function clip() {
    pbcopy < "${@}"
}

# Have mkdir create parent directories if they don't already exist
alias mkdir="mkdir -p"


# Grep chain commands
alias hgr='history | gr'
alias pgr='ps aux | gr'

# Load the latest history from all tabs before modifying the history
# This allows me to see history from all tabs
# NOTE: relies on the 'history -a' in my PROMPT_COMMAND
history() {
    builtin history -n
    builtin history "${@}"
}

# Map command to open last vim session
alias vim="nvim"
alias v="vim"
alias vi="vim"

# Jobs should show PID by default
alias jobs="jobs -l"

# Easy SSH port forwarding
function sshl { 
    COMMAND="${@:2}"
    ssh -L "${1}:localhost:${1}" "${COMMAND[@]}"
}

# Command line JSON prettifier
alias prettify-json="python -mjson.tool"

# Just because it's intuitive
alias eject="diskutil unmount"

# Adds a `chrome` command that I use for rendering Markdown files, with completion
# TODO: make this also open .sheet files in Google drive by examining the link
alias chrome="open -a 'Google Chrome'"
_chrome_completion() {
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local IFS=$'\n'
    local matches=()

    for entry in $(compgen -f -- "$cur"); do
        if [ -d "$entry" ]; then
            matches+=("${entry}/")
        elif echo "$entry" | grep -q '\.md$'; then
            matches+=("$entry")
        elif echo "$entry" | grep -q '\.html$'; then
            matches+=("$entry")
        fi
    done

    COMPREPLY=("${matches[@]}")

    # Prevent trailing space after completion so directories can be drilled into
    if [ ${#COMPREPLY[@]} -eq 1 ] && echo "${COMPREPLY[0]}" | grep -q '/$'; then
        compopt -o nospace
    fi
}
complete -F _chrome_completion chrome # Allow completion of Markdown files, and directories that might have Markdown files

function 1p() {
    # TODO If no arguments are provided, let's do some fzf magic
    op "${@}"
    return "${?}"
}
complete -o default -F __start_op 1p  # We hijack 1Password's completion for our alias

function replace() {
    needle="${1:-}"
    replacement="${2:-}"
    filename_regex="${3:-}"

    if [ -z "${needle}" ]; then
        echo "Error: First argument must be a string to find" >&2
        return 1
    fi
    if [ -z "${replacement}" ]; then
        echo "Error: Second argument must be a string to replace found patterns with" >&2
        return 1
    fi
    if [ -z "${filename_regex}" ]; then
        echo "Error: Third argument must be a 'find'-compatible regex of filenames to match" >&2
        return 1
    fi

    local DELETE_SUFFIX=".deleteme"
    sed -i"${DELETE_SUFFIX}" "s?${needle}?${replacement}?g" $(find . -name "${filename_regex}")
    find . -name "*${DELETE_SUFFIX}" -delete
}

# ======================================================================================
#                                   Searching & Navigating
# ======================================================================================
alias csgr='grep -I --color=auto'    # Case-sensitive grep
alias gr='csgr -i'
alias csegr='grep -I --color=auto' # Case-sensitive egrep
alias egr='csegr -i'
alias fgrep='fgrep --color=auto'
alias egrep='egrep --color=auto'
function rgr() { gr --exclude-dir="." --exclude-dir=".." -r "$@" ./* ./.*; }
function csrgr() { csgr --exclude-dir="." --exclude-dir=".." -r "$@" ./* ./.*; }  # Case-sensitive recursive grep
function ergr() { egr --exclude-dir="." --exclude-dir=".." -r "$@" ./* ./.*; }
function csergr() { csegr --exclude-dir="." --exclude-dir=".." -r "$@" ./* ./.*; }  # Case-sensitive recursive egrep

# Given a file, detects what type it is and:
# 1) cd's to it if it's a directory
# 2) opens it in Vim if it's a text file
# 3) throws an error if it's a binary file
function smart_open {
    filepath="${1}"
    if ! [ -e "${filepath}" ]; then
        echo "Error: No such file at '${filepath}'" >&2
        return 1
    fi

    # TODO Handle multiple input files (probably using fzf, or something like cmdk)
    mime_type="$(file -b --mime-type "${filepath}")"
    program=""
    case "${mime_type}" in
        text/*)
            program="vim"
            ;;
        application/json)
            program="vim"
            ;;
        inode/directory)
            program="cd"
            ;;
        application/pdf)
            program="open"
            ;;
        application/vnd.openxmlformats-officedocument.wordprocessingml.document)
            program="open"
            ;;
        image/*)
            program="open"
            ;;
        *)
            echo "Error: Unknown MIME type: ${mime_type}" >&2
            return 1
            ;;
    esac
    "${program}" "${filepath}"
}
alias so="smart_open"

# TODO Idea:
# Fuzzy_find and fuzzy_ls can take an additional argument of the directory to search!

# Make find not suck, and exclude some sensible defaults (which I hope don't come back to bite me one day...)
alias cif="find . ! -name '*.class' -and -iname" # Case-insensitive find
function fuzzy_find() { 
    ARGS="${@}"
    ARGS="${ARGS%%/}"  # Remove trailing slash so we can find directories by name
    cif "*${ARGS// /*}*"
}
function fuzzy_ls() {
    ARGS="${@}"
    ARGS="${ARGS%%/}"  # Remove trailing slash so we can find directories by name
    cif "*${ARGS// /*}*" -maxdepth 1
}
alias ff="fuzzy_find"
alias fl="fuzzy_ls"

# Allows user to choose which lines of piped input to pass through
alias filter="${HOME}/.bash_utils/filter.py"

# Pipes the output of the given command to filter
function _pipe_to_filter() {
    "${@}" | filter
}
alias fff="_pipe_to_filter fuzzy_find"

# Fuzzy searches for the given file, then filters output and feeds it into the given command
# $1 - Command to feed chosen file to
# $2 - Command to generate results for filtering
# $3+ - Arguments passed to command for generating results to filter
function use_command_filter_results() {
    # Unquoted word-splitting is intentional here
    ${1} $(${2} "${@:3}" | filter)
}

alias vff="use_command_filter_results 'vim -O' fuzzy_find"
alias vfl="use_command_filter_results 'vim -O' fuzzy_ls"
alias sff="use_command_filter_results 'smart_open' fuzzy_find"
alias sfl="use_command_filter_results 'smart_open' fuzzy_ls"

# $1 - arguments to pass to ls
# $2 - function to use to sort ls results (head|tail)
# $3 - number of results to ask for from head/tail
function _ls_results {
    ls "$1" | "$2" -n "$3"
}

# TODO Idea:
# "newest", "oldest", etc. can also take in a path to search for files on, perhaps? E.g. "newest 3 ~/Downloads*.par" says
# "Find the newest 3 files in ~/Downloads.par"

# Returns the __ most-recently-modified files
function newest {
    if [[ $# -eq 0 ]]; then
        NUM_RESULTS=1
    else
        NUM_RESULTS=$1
    fi
    _ls_results '-tr' 'tail' "$NUM_RESULTS"
}
alias latest="newest"

# Returns the __ least-recently-modified files
function oldest {
    if [[ $# -eq 0 ]]; then
        NUM_RESULTS=1
    else
        NUM_RESULTS=$1
    fi
    _ls_results '-tr' 'head' "$NUM_RESULTS"
}
alias earliest="oldest"

# Returns the __ first files alphabetically from ls
function first {
    if [[ $# -eq 0 ]]; then
        NUM_RESULTS=1
    else
        NUM_RESULTS=$1
    fi
    _ls_results '' 'head' "$NUM_RESULTS"
}

# Returns the __ last files alphabetically from ls
function last {
    if [[ $# -eq 0 ]]; then
        NUM_RESULTS=1
    else
        NUM_RESULTS=$1
    fi
    _ls_results '' 'tail' "$NUM_RESULTS"
}

# Returns the __ biggest files by filesize
function biggest {
    if [[ $# -eq 0 ]]; then
        NUM_RESULTS=1
    else
        NUM_RESULTS=$1
    fi
    _ls_results '-Sr' 'head' "$NUM_RESULTS"
}

# Returns the __ smallest files by filesize
function smallest {
    if [[ $# -eq 0 ]]; then
        NUM_RESULTS=1
    else
        NUM_RESULTS=$1
    fi
    _ls_results '-Sr' 'tail' "$NUM_RESULTS"
}

# ======================================================================================
#                                            Vim 
# ======================================================================================
alias sp="vim -o"
alias vsp="vim -O"

# ======================================================================================
#                                      Git
# ======================================================================================
# Viewing changes
alias gs="git status -sb"
alias gsh="git show"
alias gd="git diff"
alias gdc="gd --cached"
alias gl="git log --graph --abbrev-commit --decorate --date=relative --format=format:'%C(bold blue)%h%C(reset) - %C(bold green)(%ar)%C(reset) %C(white)%s%C(reset) %C(bold black)[%an]%C(reset)%C(bold yellow)%d%C(reset)' --all"

# Making changes
alias gb="git branch"
function gco {
    if [ "${#}" -ne 0 ]; then
        git checkout "${@}"
        return "${?}"
    fi

    # Use fzf to select branches from most-recent-branches if no args are provided
    tmpfile=$(mktemp)
    tmpfile_all="${tmpfile}.all"
    tmpfile_sorted="${tmpfile}.sorted"
    tmpfile_deduped="$(mktemp)"

    # Step 1: generate triples of (full_branch_name,short_branch_name,timestamp) for local & remote branches
    {
        git for-each-ref --format='%(refname:short),%(refname:short),%(committerdate:unix)' refs/heads/

        git for-each-ref --format='%(refname:short),%(committerdate:unix)' refs/remotes/ | \
            awk -F',' '{
                full = $1;
                gsub(/^origin\//, "", $1);
                print full "," $1 "," $2
            }'
    } > "${tmpfile_all}"

    # Step 2: sort by short branch name to put local & remote branch lines next to each other
    sort -t',' -k2,2 -k3,3nr "${tmpfile_all}" > "${tmpfile_sorted}"

    # Step 3: dedupe by short_name, preferring the local row if it's present
    # TODO hardcodes 'origin', which might be a problem at some point in the distant future
    awk -F',' '
    {
        full = $1; short = $2; ts = $3
        is_remote = (full ~ /^origin\//)
        if (!(short in seen) || (!is_remote && source[short] == "remote")) {
            seen[short] = full "," short "," ts
            source[short] = is_remote ? "remote" : "local"
        }
    }
    END {
        for (s in seen) print seen[s]
    }
' "${tmpfile_sorted}" > "${tmpfile_deduped}"

    rm "${tmpfile_all}" "${tmpfile_sorted}"

    # Step 4: final sort by timestamp descending
    sort -t',' -k3,3nr "${tmpfile_deduped}" | cut -d',' -f1 | fzf --bind='enter:become(git checkout {})'

    rm "${tmpfile_deduped}" # Not THAT important if this doesn't run (since it's a tempfile, and a small one)
}

# Same as 'gco', except does a stash & stash pop
gcos() {
    git stash
    echo "ðŸ“¥ STASHED CHANGES"
    gco "${@}"

    # Intentionally not checking the error code of "gco", so that the stash goes
    git stash pop
    echo "ðŸ“¤ UNSTASHED CHANGES"
}

ga() {   # Use fzf to select files if no arguments are provided
    if [ $# -eq 0 ]; then
        local candidates
        candidates=$(git status --porcelain | grep '^[ MARC][ MD]' | cut -c4-)

        if [ -z "$candidates" ]; then
            echo "Working directory clean; no files to add."
            return
        fi

        local selection
        selection=$(echo -e "[ALL]\n$candidates" | fzf -m --prompt="Add files: ")

        if [[ "$selection" == *"[ALL]"* ]]; then
            echo "$candidates" | xargs git add --
        elif [ -n "$selection" ]; then
            echo "$selection" | xargs git add --
        fi
    else
        git add "$@"
    fi
}

# We hijack Git's autocomplete here so we get autocompletion on our custom aliases
# This relies on the bash-completion Homebrew package being loaded before this runs
if command -v __git_complete > /dev/null; then
    __git_complete gco _git_checkout
    __git_complete gb _git_branch
fi

alias empty-commit="git commit --allow-empty -m $1"
alias gcm="git commit"
alias gcmm="git commit -m $1"
alias gg="git commit -am $1"
grs() {    # Use fzf to select files to reset if no arguments are provided
    if [ $# -eq 0 ]; then
        local candidates
        candidates=$(git status --porcelain | grep '^[ MARC][ MD]' | cut -c4-)

        if [ -z "$candidates" ]; then
            echo "Working directory clean; no files to unstage."
            return
        fi

        local selection
        selection=$(echo -e "[ALL]\n$candidates" | fzf -m --prompt="Reset files: ")

        if [[ "$selection" == *"[ALL]"* ]]; then
            echo "$candidates" | xargs git reset --
        elif [ -n "$selection" ]; then
            echo "$selection" | xargs git reset --
        fi
    else
        git reset "$@"
    fi
}
alias grs1="git reset --soft HEAD^"

# Dealing with remotes
alias gcl="git clone"
alias gf="git fetch --prune"
alias gpl="git pull"
function gp() {	# Push the branch upstream if it doesn't exist; otherwise just git push
	BRANCH_NAME="$(git rev-parse --abbrev-ref HEAD)"
	if [[ $(git config "branch.$BRANCH_NAME.merge") == '' ]]; then
            git push -u origin "$BRANCH_NAME" "$@"
        else
            git push "$@"
        fi
}
alias gprune-local-dry-run="git branch --merged | grep -v '\*' | grep -v 'master' | grep -v 'develop'"
alias gprune-local="git branch --merged | grep -v '\*' | grep -v 'master' | grep -v 'develop' | xargs -n 1 git branch -d"


# ======================================================================================
#                                      Github
# ======================================================================================
alias ghi="bash ${HOME}/.bash_utils/gh-issue-create.sh"

# ======================================================================================
#                                      Gradle
# ======================================================================================
# Searches for a gradlew file up the tree and uses it for gradle commands
# Add 'nocd' as the first argument to run the gradle commands from the directory you're in at the moment
function gradle_search() {
    ORIG_DIR="$PWD"
    while [[ "$PWD" != "/" ]]; do
        if [[ -f "./gradlew" ]]; then
            if [[ "$1" == "nocd" ]]; then
                GRADLE_DIR=$(pwd)
                cd "$ORIG_DIR"
                echo "$GRADLE_DIR"/gradlew "${@:2}"
                "$GRADLE_DIR"/gradlew "${@:2}"
            else
                ./gradlew --daemon "$@"
                cd "$ORIG_DIR"
            fi
            return 0
        else
            cd ..
        fi
    done
    cd "${ORIG_DIR}"
    echo "No gradlew file found in any parent directories" >&2
}
alias grd="gradle_search"

alias rsync="rsync --perms --progress"

# Easy SSH aliases
# Interesting tidbit: I used to have a 'for line in $(grep '^Host.....)' thing here, but 
# one of my HostName entries in my SSH config file was '*', which was getting Bash glob-expanded and causing problems!
# Lesson learned...
grep '^Host' "${HOME}/.ssh/config" | grep -v '[*]' | awk '{print $2}' | while read -r ssh_host; do
    alias "${ssh_host}"="ssh '${ssh_host}'"
done

alias virtualenv="pyenv virtualenv"

# Make following a file much easier
alias lsf="less +F"

# Call this script and pass a text file with a list of servers. You will ssh to the servers as the current user.
# Once connected use Ctrl + a to enter commands
# de/syncronize panes = Ctrl + a + s
# Change panes = Ctrl + a + arrow-keys
# Zoom into pane = Ctrl + a + z
function parallel-tmux() {
    tmux new-session -s $(date +"%F_%H-%M-%S") -d
    count=-1
    for i in $(cat $1); do
      let count=${count}+1
      if [ $count -eq 0 ]; then
        tmux new-window "ssh $i"
      else
        tmux split-window -h "ssh $i"
        tmux select-layout tiled
      fi
    done
    tmux set-window-option synchronize-panes on
    tmux attach
}



# ======================================================================================
#                                      Navigation
# ======================================================================================

# TODO replace this with all fzf stuff
function _smart_open_dir_file {
    cd "${2}"
    if [ "${#}" -gt 2 ]; then
        use_command_filter_results 'smart_open' "${1}" "${@:3}"
    fi
}

dotfiles_dirpath="${HOME}/app/dotfiles"
alias dotfiles="cd '${dotfiles_dirpath}'"

code_dirpath="${HOME}/code"

# Alias for jumping around code directories
# If no arguments are specified, then we go directly to the code directory
# If any number of arguments are specified, they're treated as search terms and...
# - If one directory matches, we go directly to it
# - If more than one directory matches, we open fzf to filter the results
function code() {
    # TODO extract into a helper function for adding fzf-completion for any subdirectory
    if [ "${#}" -eq 0 ]; then
        cd "${code_dirpath}"
        return 0
    fi

    query_terms="${*}"
    glob_query="*${query_terms// /*}*"

    dirs_matching_glob="$(find "${code_dirpath}" -maxdepth 1 -type d -iname "${glob_query}" -exec basename {} \;)"
    num_matches="$(echo -n "${dirs_matching_glob}" | grep -c '^')"
    
    # If we only have one match, then go directly to it
    if [ "${num_matches}" -eq 1 ]; then
        cd "${code_dirpath}/${dirs_matching_glob}"
        return 0
    fi

    selected_dirname="$(
        find "${code_dirpath}" -maxdepth 1 -type d -exec basename {} \; | fzf --query "${query_terms}"
    )"

    if [ -z "${selected_dirname}" ]; then
        return 0
    fi

    cd "${code_dirpath}/${selected_dirname}"
}

writing_dirpath="${code_dirpath}/personal-writing"
alias pwriting="cd ${writing_dirpath}"   # TODO upgrade this to take in a search term and optionally 'cd' to that

downloads_dirpath="${HOME}/Downloads"
alias downloads="_smart_open_dir_file fuzzy_ls '${downloads_dirpath}'"

gdrive_dirpath="${HOME}/gdrive"
alias gdrive="_smart_open_dir_file fuzzy_ls '${gdrive_dirpath}'"

check_dirpath="${gdrive_dirpath}/checklists-and-templates"
alias check="_smart_open_dir_file fuzzy_find '${check_dirpath}'"

gref_dirpath="${gdrive_dirpath}/general-reference"
alias gref="_smart_open_dir_file fuzzy_find '${gref_dirpath}'"

receipts_dirpath="${gdrive_dirpath}/receipts-records-confirmations"
alias receipts="_smart_open_dir_file fuzzy_find '${receipts_dirpath}'"

psup_dirpath="${gdrive_dirpath}/project-support"
alias psup="_smart_open_dir_file fuzzy_ls '${psup_dirpath}'"

someday_dirpath="${gdrive_dirpath}/someday-maybe"
alias someday="_smart_open_dir_file fuzzy_find '${someday_dirpath}'"

self_improvement_dirpath="${gref_dirpath}/self-improvement"
alias selfimprovement="_smart_open_dir_file fuzzy_find '${self_improvement_dirpath}'"

work_gdrive_dirpath="${HOME}/work-gdrive"
alias work-gdrive="_smart_open_dir_file fuzzy_ls '${work_gdrive_dirpath}'"

alias til="vim ${gref_dirpath}/today-i-learned.md"

alias assistant="cd ${code_dirpath}/assistant && claude"

alias tmp="cd /tmp"

alias baliases="vim ${HOME}/.bash_aliases"
alias vimrc="vim ${HOME}/.vimrc"

alias home="cd ${HOME}"

# ======================================================================================
#                                      Docker
# ======================================================================================
clear_containers() {
    docker rm $(docker stop $(docker ps -a --quiet --format="{{.ID}}"))
}
alias cclear=clear_containers
function volume_exec() {
    volume_name="${1}"
    shift 1

    volume_path="$(docker volume inspect "${volume_name}" | grep 'Mountpoint' | awk '{print $2}' | sed 's/"\(.*\)",/\1/g')"
    full_volume_path="/docker${volume_path}"

    num_args="${#}"
    penultimate_arg_index="$((num_args - 1))"

    path_inside_volume="${1}"
    if [ "${num_args}" -gt 1 ]; then
        set -- "${@:1:${penultimate_arg_index}}" "${full_volume_path}/${@:${num_args}}"
    else
        set -- "${full_volume_path}/${@:${num_args}}"
    fi

    docker run --rm -it -v /:/docker alpine:edge "${@}"
}

clear_old_images() {
    docker image rm $(docker images --quiet --filter "dangling=true")
}
alias iclear=clear_old_images



# ======================================================================================
#                                      Kubernetes
# ======================================================================================
alias k8s="kubectl"


# ======================================================================================
#                                      Kurtosis
# ======================================================================================
# Alias 'kt' to 'kurtosis'
alias kt="kurtosis"
complete -F __start_kurtosis kt

# Alias 'kt' to the dev version of Kurtosis
alias ktdev="${code_dirpath}/kurtosis-monorepo/cli/cli/scripts/launch-cli.sh"

# ======================================================================================
#                                      Python
# ======================================================================================
alias python="python3"


# ======================================================================================
#                                  ffmpeg + gifsicle
# ======================================================================================
function gifinate() {
    if [ "${#}" -ne "2" ]; then
        echo "Usage: gifinate input_filepath output_size" >&2
        echo "Note that size will be in WxH format" >&2
        return 1
    fi
    input_filepath="${1}"
    output_size="${2}"

    if [ "${input_filepath%%.mov}" = "${input_filepath}" ]; then
        echo "Error: Input filepath must be a .mov" >&2
        return 1
    fi

    ffmpeg -i "${input_filepath}" -s "${output_size}" -pix_fmt rgb24 -r 15 -f gif - | gifsicle --optimize=3 --delay=3 > "${input_filepath}.gif"
}



# ======================================================================================
#                                  Custom-Built Apps
# ======================================================================================
# Wealthdraft aliases
function wealthdraft() {
    binary_dirpath="/wealthdraft"
    configs_dirpath="/config"
    docker run --rm \
        -v "${code_dirpath}/wealthdraft-personal-configs:${configs_dirpath}" \
        -v "${HOME}/app/wealthdraft:${binary_dirpath}" \
        amazoncorretto:11-alpine \
        sh -c "java -jar ${binary_dirpath}/*.jar \
            --gov-constants ${configs_dirpath}/gov-constants.yml \
            --scenarios ${configs_dirpath}/scenarios.yml \
            --assets ${configs_dirpath}/assets.yml \
            --assets-history ${configs_dirpath}/assets-history.yml \
            --projections ${configs_dirpath}/projections.yml \
            --asset-allocations ${configs_dirpath}/asset-allocations.yml \
            --filters ${configs_dirpath}/filters.yml \
            --all"

}


# ======================================================================================
#                                    CLI Journal
# ======================================================================================
export journal_dirpath="${gdrive_dirpath}/journal"   # Must be exported so fzf can use this

# Helper function to sanitize journal names from arguments
_sanitize_journal_name() {
    local joined_name="${*}"
    local sanitized_name="${joined_name// /-}"
    
    # Remove .md extension if present
    sanitized_name="${sanitized_name%.md}"
    
    # Check if empty after sanitization
    if [ -z "${sanitized_name}" ]; then
        return 1
    fi
    
    echo "${sanitized_name}"
}

# Builds a list of the files in the CLI journal, for use with fzf
_fzf_journal_find_cmd() {
    fd -e md -t f . "${journal_dirpath}" |                                   # list *.md only
    awk -v OFS=$'\t' '
    BEGIN {
        grey  = "\033[90m"   # dark-grey (bright black)
        yellow= "\033[33m"
        reset = "\033[0m"
    }
    {
        path = $0
        file = $0
        sub(/.*\//, "", file)     # strip leading dirs
        sub(/\.md$/, "", file)    # strip .md

        n      = split(file, parts, "~")
        entry  = parts[1]                       # FIRST
        tsraw  = (n>=2 ? parts[2] : "")         # SECOND  YYYY-MM-DD_HH-mm-SS

        split(tsraw, t, "_")
        gsub(/-/, ":", t[2])                    # HH-mm-SS â†’ HH:mm:SS
        tspretty = t[1] " " t[2]                # YYYY-MM-DD HH:mm:SS

        # columns: 1=path, 2=coloured timestamp, 3=plain entry, 4=raw timestamp
        print path, yellow tspretty reset, entry, tsraw
    }' |
    sort -t $'\t' -k4,4r
}
export -f _fzf_journal_find_cmd  # Need to export this so fzf can use it

alias journal="activate_jenv_and_java_home && java -jar ${HOME}/app/cli-journal/*.jar"

# This is a helper function for creating files from templates.
#
# It will open a buffer in Vim with the template contents, ready to write to the desired destination.
# Saving will only happen when the user does ':w', however.
#
# This function will also:
# - Transform any lines in the template with <!-- mark:x --> into an actual mark 'x' (or 'a', or whatever)
# - Load the 'w' register with the string 'WHY: ' for doing 'why' reflection (see https://github.com/mieubrisse/lifeops-toolkit/blob/main/reflection.md )
# - Load the 'e' register with a macro ready to create a newline with a nested 'WHY: ' bulletpoint
_open_file_from_template_without_writing() {
    local template="${1}"
    local filepath="${2}"

    # Process template content: replace <!-- mark:x --> lines with empty lines and generate vim mark commands
    local vim_mark_commands=()
    local processed_content=""
    local line_number=1
    
    while IFS= read -r line; do
        if [[ "${line}" =~ ^\<!--[[:space:]]*mark:([a-zA-Z])[[:space:]]*--\>$ ]]; then
            # Extract the mark letter
            local mark_letter="${BASH_REMATCH[1]}"
            # Replace the mark line with an empty line
            processed_content+=$'\n'
            # Add vim command to set the mark on this line
            vim_mark_commands+=("-c" "${line_number}mark ${mark_letter}")
        else
            processed_content+="${line}"$'\n'
        fi
        ((line_number++))
    done < "${template}"

    # NOTE: breaks if 'filepath' has spaces
    printf '%s' "${processed_content}" | vim -n -i NONE \
        -c "setlocal noundofile noswapfile" \
        -c "setlocal filetype=markdown" \
        -c "file ${filepath}" \
        -c "call setreg('w', 'WHY: ')" \
        -c "call setreg('e', 'o    - WHY: ')" \
        "${vim_mark_commands[@]}"
}

# Create a new journal entry
jn() {
    local sanitized_name
    if ! sanitized_name=$(_sanitize_journal_name "${@}"); then
        echo "Error: Provide name for journal entry: jn [name_fragments...]" >&2
        return 1
    fi
    
    journal new "${sanitized_name}.md"
}

# Create a journal entry from template
jt() {
    local sanitized_name
    if ! sanitized_name=$(_sanitize_journal_name "${@}"); then
        echo "Error: Provide name for journal entry: jt [name_fragments...]" >&2
        return 1
    fi
    
    # Use fd and fzf to select a template from check_dirpath (excluding ARCHIVE)
    template_file=$(fd -e md -t f -t l -E ARCHIVE . "${check_dirpath}" | fzf --prompt="Select template: ")
    
    if [ -z "${template_file}" ]; then
        echo "No template selected" >&2
        return 1
    fi
    
    # Create destination path with tilda-separated pattern like new-packing-checklist
    dest_filepath="${journal_dirpath}/${sanitized_name}~$(now)~.md"
    
    # Copy template to destination and open in vim
    cp "${template_file}" "${dest_filepath}"
    vim "${dest_filepath}"
}

# Find a journal entry
jf() {
    # Explaining:
    # - scheme=history so that 'needle-foo' is ranked equal to 'foo-needle' when searching for 'needle'
    # - tiebreak=index so that things ranked equally are subsorted by timestamp
    # - query=${*} prints all the args as a single string, separated by a space
    mapfile -t output_paths < <(FZF_DEFAULT_COMMAND="_fzf_journal_find_cmd" fzf \
        -m \
        --ansi \
        --delimiter=$'\t' \
        --with-nth='{2}   {3}' \
        --accept-nth=1 \
        --bind='change:top' \
        --scheme=history \
        --tiebreak=index \
        --query="${*}"
    )

    if [ "${#output_paths[@]}" -gt 0 ]; then
        vim -O "${output_paths[@]}"
    fi
}


# "coaching journal new"
cjn() {
    # Form journal_name from space-separated args as fragments of journal filename (see 'jn' function for inspiration)
    local journal_name
    if ! journal_name=$(_sanitize_journal_name "${@}"); then
        echo "Error: Provide name for journal entry: cjn [name_fragments...]" >&2
        return 1
    fi
    
    # Store client_dirname from result of fzf for directories in ${work_gdrive_dirpath}
    client_dirname=$(find "${work_gdrive_dirpath}" -maxdepth 1 -type d -not -path "${work_gdrive_dirpath}" -exec basename {} \; | fzf --prompt="Select client: ")
    
    # If fzf was cancelled or an error occured, exit the function with return code 1
    if [ -z "${client_dirname}" ]; then
        return 1
    fi
    
    # Store journal_entry_filename=${client_dirname}-${journal_name}~TIMESTAMP~.md (where TIMESTAMP matches the format of 'jn')
    timestamp="$(now)"
    journal_entry_filename="${client_dirname}-${journal_name}~${timestamp}~.md"
    journal_entry_filepath="${journal_dirpath}/${journal_entry_filename}"
    
    # Create a symlink called YYYY-MM-DD_HH-mm-SS_NAME_${journal_name}.md (filling in the appropriate fields) inside ${work_gdrive_dirpath}/${client_dirname}
    symlink_filename="${timestamp}_${journal_name}.md"
    symlink_filepath="${work_gdrive_dirpath}/${client_dirname}/${symlink_filename}"
    
    # Create the symlink (will be broken until user saves in vim)
    ln -sf "${journal_entry_filepath}" "${symlink_filepath}"
    
    # Open the journal file in vim
    vim "${journal_entry_filepath}"
}


alias todays-goals="journal new todays-goals.md todays-goals"

# ======================================================================================
#                                Overpowered Writing Tools
# ======================================================================================
alias pj="jump_post"
alias pe="edit_post"
alias pn="new_post"
alias pp="publish_post"

# ======================================================================================
#                                    Health Journal
# ======================================================================================
alias health="vim ${gref_dirpath}/health/health-journal.md"


# ======================================================================================
#                                    Health Journal
# ======================================================================================
alias musings="vim ${gref_dirpath}/musings/one-off-musings.md"

# ======================================================================================
#                             Daily/Weekly/Monthly Reflections
# ======================================================================================
day() {
    entry_filepath="${journal_dirpath}/daily-journalling~$(now)~.md"
    _open_file_from_template_without_writing "${check_dirpath}/daily-journalling.md" "${entry_filepath}"
}

get_week_plan_filepath() {
  # Ensure psup_dirpath is set
  if [ -z "${psup_dirpath}" ]; then
    echo "Error: psup_dirpath is not set."
    return 1
  fi

  # Get the date for Sunday of the current week
  # We have to use Gnu date (gdate) since Mac date doesn't have the -d option
  week_date="$(gdate -d "last sunday +0 days" +"%Y-%m-%d")"

  # Special case: if today is Sunday, use today
  if [ "$(date +%u)" -eq 7 ]; then
    week_date="$(date +"%Y-%m-%d")"
  fi

  # Construct the file path
  echo "${journal_dirpath}/week-plan~${week_date}_12-00-00.md"
}

# Weekly planning function - opens previous and current week side-by-side for review
# Uses Wednesday as threshold: Mon-Wed reviews last week vs current week, Thu-Sun reviews current week vs next week
# Creates new week files from weekly-planning.md template, sets 'w' register to 'WHY: '
week() {
    local current_day_of_week=$(date +%u)  # 1=Monday, 7=Sunday
    local template_weekly_planning_filepath="${check_dirpath}/weekly-planning.md"
    
    # Calculate which weeks are "passed" and "to come" based on Wednesday threshold
    # Days 1-3 (Mon-Wed): last week is "passed", current week is "to come"
    # Days 4-7 (Thu-Sun): current week is "passed", next week is "to come"
    if [ "${current_day_of_week}" -gt 3 ]; then
        # After Wednesday: current week is "passed", next week is "to come"
        passed_week_date="$(gdate -d "last sunday +0 days" +"%Y-%m-%d")"
        if [ "$(date +%u)" -eq 7 ]; then
            passed_week_date="$(date +"%Y-%m-%d")"
        fi
        to_come_week_date="$(gdate -d "next sunday +0 days" +"%Y-%m-%d")"
    else
        # Before Thursday: last week is "passed", current week is "to come"
        passed_week_date="$(gdate -d "last sunday -7 days" +"%Y-%m-%d")"
        to_come_week_date="$(gdate -d "last sunday +0 days" +"%Y-%m-%d")"
        if [ "$(date +%u)" -eq 7 ]; then
            to_come_week_date="$(date +"%Y-%m-%d")"
        fi
    fi
    
    # Create file paths
    passed_week_filepath="${journal_dirpath}/week-plan~${passed_week_date}_12-00-00.md"
    to_come_week_filepath="${journal_dirpath}/week-plan~${to_come_week_date}_12-00-00.md"
    
    # Create the "to come" week file from template if it doesn't exist
    if [ ! -f "${to_come_week_filepath}" ]; then
        cp "${template_weekly_planning_filepath}" "${to_come_week_filepath}"
    fi
    
    # Open both files side by side with 'w' register set to 'WHY: '
    if [ ! -f "${passed_week_filepath}" ]; then
        # Create temporary file with message
        temp_file=$(mktemp)
        echo "No past week reflection file exists" > "${temp_file}"
        vim -O "${temp_file}" "${to_come_week_filepath}" \
            -c "call setreg('w', 'WHY: ')" \
            -c "autocmd VimLeave * silent! call delete('${temp_file}')"
    else
        vim -O "${passed_week_filepath}" "${to_come_week_filepath}" \
            -c "call setreg('w', 'WHY: ')"
    fi
}

# Monthly planning function - opens previous and current month side-by-side for review
# Uses 25th as threshold: before 25th reviews last month vs current month, after 25th reviews current month vs next month
# Creates new month files from monthly-goals.md template in self_improvement_dirpath
month() {
    local current_day=$(date +%d)
    local current_month_year=$(date +%Y-%m)

    local template_month_goals_filepath="${check_dirpath}/monthly-goals.md"
    
    # Calculate which months are "passed" and "to come" based on the 25th threshold
    if [ "${current_day}" -gt 25 ]; then
        # After 25th: current month is "passed", next month is "to come"
        passed_month_year="${current_month_year}"
        to_come_month_year=$(gdate -d "next month" +%Y-%m)
    else
        # Before 25th: last month is "passed", current month is "to come"
        passed_month_year=$(gdate -d "last month" +%Y-%m)
        to_come_month_year="${current_month_year}"
    fi
    
    # Set up file paths
    passed_month_dirpath="${self_improvement_dirpath}/${passed_month_year}"
    passed_month_filepath="${passed_month_dirpath}/month-goals.md"
    
    to_come_month_dirpath="${self_improvement_dirpath}/${to_come_month_year}"
    to_come_month_filepath="${to_come_month_dirpath}/month-goals.md"
    
    # Create directory for the month to come if it doesn't exist
    mkdir -p "${to_come_month_dirpath}"

    if ! [ -f "${to_come_month_filepath}" ]; then
        cp "${template_month_goals_filepath}" "${to_come_month_filepath}"
    fi
    
    # Build vim command arguments
    vim_args=()
    
    # Always add the to come month file
    vim_args+=("${to_come_month_filepath}")

    # Add passed month file if it exists
    if [ -f "${passed_month_filepath}" ]; then
        vim_args+=("${passed_month_filepath}")
    fi
    
    # Open in vertical split if we have both files, otherwise just open the single file
    if [ ${#vim_args[@]} -eq 2 ]; then
        vim -O "${vim_args[@]}"
    else
        vim "${vim_args[@]}"
    fi
}

# ======================================================================================
#                                    Myopia Planning
# ======================================================================================
myopia_planning_filepath="${psup_dirpath}/myopia-planning.md"
alias myopia="vim ${myopia_planning_filepath}"

# ======================================================================================
#                                    FounderOS
# ======================================================================================
founderos_dirpath="${gref_dirpath}/2025_founderos"
alias founderos="cd ${founderos_dirpath}"
alias compounding-sow="vim ${founderos_dirpath}/state-of-the-world-journal.md"

lifeops_dirpath="${code_dirpath}/lifeops-toolkit"
alias lifeops="cd ${lifeops_dirpath}"

alias vision="vim ${self_improvement_dirpath}/2025-10/vision-board.md"


# ======================================================================================
#                                     Claude
# ======================================================================================

# This is a wrapper around Claude to detect & inject 1Password secret references into Claude
claude() {
    # If stdin is being piped, use -p mode without op run
    if [ ! -t 0 ]; then
        ${BREW_PREFIX}/bin/claude -p "${@}"
    elif [ -f ".claude/secrets.env" ]; then
        # We have to add the 'script -q /dev/null' due to a Claude bug: https://github.com/anthropics/claude-code/issues/4930
        op run --env-file ".claude/secrets.env" -- script -q /dev/null "${BREW_PREFIX}/bin/claude" "${@}"
    else
        ${BREW_PREFIX}/bin/claude "${@}"
    fi
}
