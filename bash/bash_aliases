#!/bin/bash

# Datetime
alias today='date +%F'
alias now='date +%F_%H-%M-%S'

# Allow editing Mac crontab with Vim per:
# http://superuser.com/questions/359580/error-adding-cronjobs-in-mac-os-x-lion
alias crontab="VIM_CRONTAB=true crontab"

# ls conveniences
function ls() { # Display an empty line for empty directories
    if [[ $(/bin/ls "${@}" | wc -l) -eq 0 ]]; then
        echo 
    else
        /bin/ls -G "$@"
    fi
}
alias ll='ls -Alhtr'
alias llt='ll -t' # Sort by date last modified
alias la='ls -A'
alias l='ls'

# du should always be human readable
alias du='du -h'

# $1 - arguments to pass to ls
# $2 - function to use to sort ls results (head|tail)
# $3 - number of results to ask for from head/tail
function _ls_results {
    ls $1 | $2 -n $3
}

# Returns the __ most-recently-modified files
function newest {
    if [[ $# -eq 0 ]]; then
        NUM_RESULTS=1
    else
        NUM_RESULTS=$1
    fi
    _ls_results '-tr' 'tail' $NUM_RESULTS
}

# Returns the __ least-recently-modified files
function oldest {
    if [[ $# -eq 0 ]]; then
        NUM_RESULTS=1
    else
        NUM_RESULTS=$1
    fi
    _ls_results '-tr' 'head' $NUM_RESULTS
}

# Returns the __ first files alphabetically from ls
function first {
    if [[ $# -eq 0 ]]; then
        NUM_RESULTS=1
    else
        NUM_RESULTS=$1
    fi
    _ls_results '' 'head' $NUM_RESULTS
}

# Returns the __ last files alphabetically from ls
function last {
    if [[ $# -eq 0 ]]; then
        NUM_RESULTS=1
    else
        NUM_RESULTS=$1
    fi
    _ls_results '' 'tail' $NUM_RESULTS
}

# Returns the __ biggest files by filesize
function biggest {
    if [[ $# -eq 0 ]]; then
        NUM_RESULTS=1
    else
        NUM_RESULTS=$1
    fi
    _ls_results '-Sr' 'head' $NUM_RESULTS
}

# Returns the __ smallest files by filesize
function smallest {
    if [[ $# -eq 0 ]]; then
        NUM_RESULTS=1
    else
        NUM_RESULTS=$1
    fi
    _ls_results '-Sr' 'tail' $NUM_RESULTS
}

# Make find not suck
alias cif="find . -iname" # Case-insensitive find
function fuzzy_find() { 
    ARGS="${@}"
    cif "*${ARGS// /*}*"
}
function fuzzy_ls() {
    ARGS="${@}"
    cif "*${ARGS// /*}*" -maxdepth 1
}
alias ff="fuzzy_find"
alias fl="fuzzy_ls"

# Overwrite cd to jump up multiple levels with 'cd <# dir>..' syntax
cd() {
    # If string isn't long enough, use builtin cd anyways
    if [[ ${#1} -lt 3 ]]; then
        builtin cd "$@"
    else
        # Check if string is in '<number>..' form
        REPEAT_TIMES="${1:0:(${#1} - 2)}"
        if [[ "${1:(-2)}" == ".." ]] && [[ "${#1}" -gt 2 ]] && [[ $REPEAT_TIMES =~ ^-?[0-9]+$ ]] && [[ $REPEAT_TIMES -ne 0 ]]; then
            CD_STR=""
            for i in $(seq 1 $REPEAT_TIMES); do
                # Yes Shellcheck, I know we don't use the indexing variable 'i'
                CD_STR="../$CD_STR"
            done
            cd "$CD_STR"
        else
            
            builtin cd "$@"
        fi
    fi
}

# Allows user to choose which lines of piped input to pass through
alias filter="~/.bash_utils/filter.py"

# Fuzzy searches for the given file, then filters output and feeds it into the given command
# $1 - Command to feed chosen file to
# $2 - Command to generate results for filtering
# $3+ - Arguments passed to command for generating results to filter
function use_command_filter_results() {
    "$1" "$(${2} "${@:3}" | filter)"
}

alias vff="use_command_filter_results vim fuzzy_find"
alias vfl="use_command_filter_results vim fuzzy_ls"

# Easily copy the contents of one or more file
function clip() {
    cat "${@}" | pbcopy
}

# Have mkdir create parent directories if they don't already exist
alias mkdir="mkdir -p"

# Make directory and cd into it
function mkdircd() { mkdir "$@"; cd "$1"; }

# === grep ===========
alias csgr='grep -I --color=auto'    # Case-sensitive grep
alias gr='csgr -i'
alias fgrep='fgrep --color=auto'
alias egrep='egrep --color=auto'
function rgr() { gr -r "$@" ./*; }
function csrgr() { csgr -r "$@" ./*; }  # Case-sensitive recursive grep

# Grep chain commands
alias hgr='history | gr'
alias pgr='ps aux | gr'

# Add an "alert" alias for long running commands.  Use like so:
# TODO This is broken
# alias alert="notify-send --urgency=low -i \"$([ $? = 0 ] && echo terminal || echo error)\" \"$(history|tail -n1|sed -e '\''s/^\s*[0-9]\+\s*//;s/[;&|]\s*alert\$//'\'')\""

# Map command to open last vim session
alias   v="vim"
# TODO I have never used this and maybe I never will
VIM_SESSION=~/.vim/.saved-session.vim
alias   vims="vim -S ${VIM_SESSION}"

# Jobs should show PID by default
alias   jobs="jobs -l"

# Don't want to make srm too easy to use!
# alias srm="srm -i"

# Output redirection functions
function    unify_output() { 2>&1 "${@}"; }
function    quiet() { "${@}" 2> /dev/null; }
function    silent() { "${@}" > /dev/null 2>&1; }

# Easy SSH port forwarding
function sshl { 
    COMMAND="${@:2}"
    echo "ssh -L $1:localhost:$1 ${COMMAND}" 
    ssh -L "$1":localhost:"$1" "${COMMAND}"
}

# Command line JSON prettifier
alias prettify-json="python -mjson.tool"

# Announces a completed task
function announce() {
	"$@"
	[[ $? == 127 ]] && return 1	# Don't speak for command not found
	VOICE_TXT=$(printf "%s" "${1}" | sed "s:.*/\(\.*\)::g")" command is done"	# Speak only command name
	say -v "Vicki" "${VOICE_TXT}"
}

# --- Git Commands ------------------------
# Viewing changes
alias gs="git status -sb"
alias gsh="git show"
alias gd="git diff --word-diff=color"
alias gdc="gd --cached"
alias gl="git log --graph --abbrev-commit --decorate --date=relative --format=format:'%C(bold blue)%h%C(reset) - %C(bold green)(%ar)%C(reset) %C(white)%s%C(reset) %C(dim white)- %an%C(reset)%C(bold yellow)%d%C(reset)' --all"
alias gll="git log --graph --abbrev-commit --decorate --format=format:'%C(bold blue)%h%C(reset) - %C(bold cyan)%aD%C(reset) %C(bold green)(%ar)%C(reset)%C(bold yellow)%d%C(reset)%n'' %C(white)%s%C(reset) %C(dim white)- %an%C(reset)' --all"

# Making changes
alias gb="git branch"
alias gco="git checkout"
alias ga="git add"
alias gcm="git commit"
alias gcmm="git commit -m $1"
alias gg="git commit -am $1"
alias grs="git reset"
alias grs1="git reset --soft HEAD^"

# Dealing with remotes
alias gcl="git clone"
alias gf="git fetch --prune"
alias gpll="git pull"
function gpsh() {	# Push the branch upstream if it doesn't exist; otherwise just git push
	BRANCH_NAME="$(git rev-parse --abbrev-ref HEAD)"
	if [[ $(git config "branch.$BRANCH_NAME.merge") == '' ]]; then
            git push -u origin "$BRANCH_NAME" "$@"
        else
            git push "$@"
        fi
}
alias gprune-local-dry-run="git branch --merged | grep -v '\*' | grep -v 'master' | grep -v 'develop'"
alias gprune-local="git branch --merged | grep -v '\*' | grep -v 'master' | grep -v 'develop' | xargs -n 1 git branch -d"

# Just because it's intuitive
alias eject="diskutil unmount"

# Because I do Py
alias ipy="ipython"

alias chrome="open -a 'Google Chrome'"

alias sp="vim -o"
alias vsp="vim -O"

# Handy convenience function for opening a meeting notes file from template
function meeting() {
    if [[ "${#}" -lt 3 ]]; then
        echo -e "Usage:\tmeeting <note destination dir> <template filepath> <note name fragment> [<note name fragment>...]"
        return 1
    fi
    dest_dirpath="${1}"
    shift
    template_filepath="${1}"
    shift
    args_str="${@}"
    filename="${args_str// /-}"
    filepath="${dest_dirpath}/$(today)_${filename%%.md}.md"
    if ! [[ -f "${filepath}" ]]; then
        vim -c "read ${template_filepath}" "${filepath}"
    else
        vim "${filepath}"
    fi
}
