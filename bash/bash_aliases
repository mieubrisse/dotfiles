#!/bin/bash

# Better diff (Mac only)
alias   diff="colordiff --ignore-space-change -u"

# Datetime
alias today='date +%F'
alias now='date +%F_%H-%M-%S'

# Allow editing Mac crontab with Vim per:
# http://superuser.com/questions/359580/error-adding-cronjobs-in-mac-os-x-lion
alias crontab="VIM_CRONTAB=true crontab"

# ls conveniences
function ls() { # Display an empty line for empty directories
    if [[ $(/bin/ls "${@}" | wc -l) -eq 0 ]]; then
        echo 
    else
        /bin/ls -G "$@"
    fi
}
alias ll='ls -Alhtr'
alias llt='ll -t' # Sort by date last modified
alias la='ls -A'
alias l='ls'

# du should always be human readable
alias du='du -h'

# $1 - arguments to pass to ls
# $2 - function to use to sort ls results (head|tail)
# $3 - number of results to ask for from head/tail
function _ls_results {
    ls "$1" | "$2" -n "$3"
}

# TODO Idea:
# "newest", "oldest", etc. can also take in a path to search for files on, perhaps? E.g. "newest 3 ~/Downloads*.par" says
# "Find the newest 3 files in ~/Downloads.par"

# Returns the __ most-recently-modified files
function newest {
    if [[ $# -eq 0 ]]; then
        NUM_RESULTS=1
    else
        NUM_RESULTS=$1
    fi
    _ls_results '-tr' 'tail' "$NUM_RESULTS"
}
alias latest="newest"

# Returns the __ least-recently-modified files
function oldest {
    if [[ $# -eq 0 ]]; then
        NUM_RESULTS=1
    else
        NUM_RESULTS=$1
    fi
    _ls_results '-tr' 'head' "$NUM_RESULTS"
}
alias earliest="oldest"

# Returns the __ first files alphabetically from ls
function first {
    if [[ $# -eq 0 ]]; then
        NUM_RESULTS=1
    else
        NUM_RESULTS=$1
    fi
    _ls_results '' 'head' "$NUM_RESULTS"
}

# Returns the __ last files alphabetically from ls
function last {
    if [[ $# -eq 0 ]]; then
        NUM_RESULTS=1
    else
        NUM_RESULTS=$1
    fi
    _ls_results '' 'tail' "$NUM_RESULTS"
}

# Returns the __ biggest files by filesize
function biggest {
    if [[ $# -eq 0 ]]; then
        NUM_RESULTS=1
    else
        NUM_RESULTS=$1
    fi
    _ls_results '-Sr' 'head' "$NUM_RESULTS"
}

# Returns the __ smallest files by filesize
function smallest {
    if [[ $# -eq 0 ]]; then
        NUM_RESULTS=1
    else
        NUM_RESULTS=$1
    fi
    _ls_results '-Sr' 'tail' "$NUM_RESULTS"
}

# TODO Idea:
# Fuzzy_find and fuzzy_ls can take an additional argument of the directory to search!

# Make find not suck
alias cif="find . -iname" # Case-insensitive find
function fuzzy_find() { 
    ARGS="${@}"
    cif "*${ARGS// /*}*"
}
function fuzzy_ls() {
    ARGS="${@}"
    cif "*${ARGS// /*}*" -maxdepth 1
}
alias ff="fuzzy_find"
alias fl="fuzzy_ls"

# Overwrite cd to jump up multiple levels with 'cd <# dir>..' syntax
cd() {
    # If string isn't long enough, use builtin cd anyways
    if [[ ${#1} -lt 3 ]]; then
        builtin cd "$@"
    else
        # Check if string is in '<number>..' form
        REPEAT_TIMES="${1:0:(${#1} - 2)}"
        if [[ "${1:(-2)}" == ".." ]] && [[ "${#1}" -gt 2 ]] && [[ $REPEAT_TIMES =~ ^-?[0-9]+$ ]] && [[ $REPEAT_TIMES -ne 0 ]]; then
            CD_STR=""
            while read; do
                CD_STR="../$CD_STR"
            done < <(seq 1 "${REPEAT_TIMES}")
            cd "$CD_STR"
        else
            
            builtin cd "$@"
        fi
    fi
}

# Allows user to choose which lines of piped input to pass through
alias filter="~/.bash_utils/filter.py"
alias ft="filter"

# Pipes the output of the given command to filter
function _pipe_to_filter() {
    "${@}" | filter
}
alias flf="_pipe_to_filter fuzzy_ls"
alias fff="_pipe_to_filter fuzzy_find"

# TODO Idea:
# Store a history of fuzzy find + filter searches,
#  and remember the choices the user makes so we
#  can give them a default choice the next time

# Fuzzy searches for the given file, then filters output and feeds it into the given command
# $1 - Command to feed chosen file to
# $2 - Command to generate results for filtering
# $3+ - Arguments passed to command for generating results to filter
function use_command_filter_results() {
    # Workd-splitting is intentional here
    $1 "$(${2} "${@:3}" | filter)"
}

alias vff="use_command_filter_results vim fuzzy_find"
alias vfl="use_command_filter_results vim fuzzy_ls"

# Easily copy the contents of one or more file
function clip() {
    pbcopy < "${@}"
}

# Have mkdir create parent directories if they don't already exist
alias mkdir="mkdir -p"

# Make directory and cd into it
function mkdircd() { mkdir "$@"; cd "$1"; }

# === grep ===========
alias csgr='grep -I --color=auto'    # Case-sensitive grep
alias gr='csgr -i'
alias csegr='grep -I --color=auto' # Case-sensitive egrep
alias egr='csegr -i'
alias fgrep='fgrep --color=auto'
alias egrep='egrep --color=auto'
function rgr() { gr --exclude-dir="." --exclude-dir=".." -r "$@" ./* ./.*; }
function csrgr() { csgr --exclude-dir="." --exclude-dir=".." -r "$@" ./* ./.*; }  # Case-sensitive recursive grep
function ergr() { egr --exclude-dir="." --exclude-dir=".." -r "$@" ./* ./.*; }
function csergr() { csegr --exclude-dir="." --exclude-dir=".." -r "$@" ./* ./.*; }  # Case-sensitive recursive egrep

# Grep chain commands
alias hgr='history | gr'
alias pgr='ps aux | gr'

# Add an "alert" alias for long running commands.  Use like so:
# TODO This is broken
# alias alert="notify-send --urgency=low -i \"$([ $? = 0 ] && echo terminal || echo error)\" \"$(history|tail -n1|sed -e '\''s/^\s*[0-9]\+\s*//;s/[;&|]\s*alert\$//'\'')\""

# Map command to open last vim session
alias   v="vim"
# TODO I have never used this and maybe I never will
VIM_SESSION=~/.vim/.saved-session.vim
alias   vims="vim -S ${VIM_SESSION}"

# Jobs should show PID by default
alias   jobs="jobs -l"

# Don't want to make srm too easy to use!
# alias srm="srm -i"

# Output redirection functions
# TODO These don't seem to work so well..
function    unify_output() { 2>&1 "${@}"; }
function    quiet() { "${@}" 2> /dev/null; }
function    silent() { "${@}" > /dev/null 2>&1; }

# Easy SSH port forwarding
function sshl { 
    COMMAND="${@:2}"
    ssh -L "${1}:localhost:${1}" "${COMMAND[@]}"
}

# Command line JSON prettifier
alias prettify-json="python -mjson.tool"

# Announces a completed task
# TODO Doesn't seem to work
function announce() {
    "$@"
    [[ $? == 127 ]] && return 1	# Don't speak for command not found
    VOICE_TXT=$(printf "%s" "${1}" | sed "s:.*/\(\.*\)::g")" command is done"	# Speak only command name
    say -v "Vicki" "${VOICE_TXT}"
}

# --- Git Commands ------------------------
# Viewing changes
alias gs="git status -sb"
alias gsh="git show"
alias gd="git diff --word-diff=color"
alias gdc="gd --cached"
alias gl="git log --graph --abbrev-commit --decorate --date=relative --format=format:'%C(bold blue)%h%C(reset) - %C(bold green)(%ar)%C(reset) %C(white)%s%C(reset) %C(bold black)[%an]%C(reset)%C(bold yellow)%d%C(reset)' --all"
alias gll="git log --graph --abbrev-commit --decorate --format=format:'%C(bold blue)%h%C(reset) - %C(bold cyan)%aD%C(reset) %C(bold green)(%ar)%C(reset)%C(bold yellow)%d%C(reset)%n'' %C(white)%s%C(reset) %C(dim white)- %an%C(reset)' --all"

# Making changes
alias gb="git branch"
alias gco="git checkout"
alias ga="git add"

# We hijack Git's autocomplete here so we get autocompletion on our custom aliases
# This relies on the bash-completion Homebrew package
__git_complete gco _git_checkout
__git_complete gb _git_branch

# TODO It's getting to the point where I need a better system for dealing with fuzzy find/ls results..
alias gaff="use_command_filter_results 'git add' fuzzy_find"
alias gafl="use_command_filter_results 'git add' fuzzy_ls"

alias empty-commit="git commit --allow-empty -m $1"
alias gcm="git commit"
alias gcmm="git commit -m $1"
alias gg="git commit -am $1"
alias grs="git reset"
alias grs1="git reset --soft HEAD^"

# TODO Finish me!
# Fugitive.vim additions
# function __fugitive_git_status() {
#     if [ local git_dirpath="$(git rev-parse --git-dir)"
#     local retcode=${?}
#     if [ 
# }
#
# alias vgs="
# alias egs="

# Dealing with remotes
alias gcl="git clone"
alias gf="git fetch --prune"
alias gpll="git pull"
function gpsh() {	# Push the branch upstream if it doesn't exist; otherwise just git push
	BRANCH_NAME="$(git rev-parse --abbrev-ref HEAD)"
	if [[ $(git config "branch.$BRANCH_NAME.merge") == '' ]]; then
            git push -u origin "$BRANCH_NAME" "$@"
        else
            git push "$@"
        fi
}
alias gprune-local-dry-run="git branch --merged | grep -v '\*' | grep -v 'master' | grep -v 'develop'"
alias gprune-local="git branch --merged | grep -v '\*' | grep -v 'master' | grep -v 'develop' | xargs -n 1 git branch -d"

# Just because it's intuitive
alias eject="diskutil unmount"

# Because I do Py
alias ipy="ipython"

alias chrome="open -a 'Google Chrome'"

alias e="vim "
alias sp="vim -o"
alias vsp="vim -O"

# Handy convenience function for opening a meeting notes file from template
function meeting() {
    if [[ "${#}" -lt 3 ]]; then
        echo -e "Usage:\tmeeting <note destination dir> <template filepath> <note name fragment> [<note name fragment>...]"
        return 1
    fi
    dest_dirpath="${1}"
    shift
    template_filepath="${1}"
    shift
    args_str="${@}"
    filename="${args_str// /-}"
    filepath="${dest_dirpath}/$(today)_${filename%%.md}.md"
    if ! [[ -f "${filepath}" ]]; then
        vim -c "read ${template_filepath}" "${filepath}"
    else
        vim "${filepath}"
    fi
}

# Convenience method for starting a new set of meeting notes for a project
# NOTE: This relies on having the 
function easy_meeting() {
    if [ -z "${meeting_notes_template_filepath}" ]; then
        echo "meeting_notes_template_filepath variable is unset; make sure it gets set in ~/.bash_local" >&2
        return 1
    fi

    project="${1}"
    shift 1
    meeting_notes_dirpath="${HOME}/Documents/${project,,}/meeting-notes"
    if ! [ -d "${meeting_notes_dirpath}" ]; then
        mkdir "${meeting_notes_dirpath}"
    fi
    meeting "${meeting_notes_dirpath}" "${meeting_notes_template_filepath}" "${@}"
}

# Convenience method for converting meeting notes to Markdown
function easy_chrome() {
    project="${1}"
    shift 1
    meeting_notes_dirpath="${HOME}/Documents/${project,,}/meeting-notes"
    (
        cd "${meeting_notes_dirpath}"

        # Interestingly, piping to 'readarray' doesn't work, but this does
        readarray -t matching_files < <(fuzzy_ls "${@}" | filter)
        echo "Length: ${#matching_files[@]}"
        if ! [ ${#matching_files[@]} -eq 0 ]; then
            echo "Doing a thing: ${matching_files[@]}"
            chrome "${matching_files[@]}"
        fi
    )
}

# Searches for a gradlew file up the tree and uses it for gradle commands
# Add 'nocd' as the first argument to run the gradle commands from the directory you're in at the moment
function gradle_search() {
    ORIG_DIR="$PWD"
    while [[ "$PWD" != "/" ]]; do
        if [[ -f "./gradlew" ]]; then
            if [[ "$1" == "nocd" ]]; then
                GRADLE_DIR=$(pwd)
                cd "$ORIG_DIR"
                echo "$GRADLE_DIR"/gradlew "${@:2}"
                "$GRADLE_DIR"/gradlew "${@:2}"
            else
                ./gradlew --daemon "$@"
                cd "$ORIG_DIR"
            fi
            return 0
        else
            cd ..
        fi
    done
    cd "${ORIG_DIR}"
    echo "No gradlew file found in any parent directories" >&2
}
alias grd="gradle_search"

alias rsync="rsync --perms --progress"

# Easy SSH aliases
# Interesting tidbit: I used to have a 'for line in $(grep '^Host.....)' thing here, but 
# one of my HostName entries in my SSH config file was '*', which was getting Bash glob-expanded and causing problems!
# Lesson learned...
grep '^Host' "${HOME}/.ssh/config" | grep -v '[*]' | awk '{print $2}' | while read -r ssh_host; do
    alias "${ssh_host}"="ssh '${ssh_host}'"
done

# Helper function to get a Gitflow param
# $1 - Partially-qualified param name, e.g. 'branch.master' or 'prefix.release'
# STDOUT - Config parameter
# RETURN - Return code of 'git config' command to retrieve the parameter
function _get_gitflow_param() {
    config_param="gitflow.${1}"
    git config --get "${config_param}"
    retcode=${?}
    if [ ${retcode} -ne 0 ]; then
        echo "Error: Could not retrieve Gitflow param ${config_param}"
    fi
    return ${retcode}
}

# Helper method to ensure that the develop and master branches are up-to-date with their remotes, and
#  returns a nonzero exit code if this is not the case
function _ensure_branch_sync() {
    echo "Checking that master & develop are in sync with remotes..."
    git fetch

    # Check against the remotes
    for config_param in master develop; do 
        config_value="$(_get_gitflow_param "branch.${config_param}" || 1)"
        diff_output="$(git log "${config_value}..origin/${config_value}" --oneline)"
        [ -z "${diff_output}" ] || return 2
    done
}

# Helper function to undo the effects of 'git flow release finish <version>', which are a pain to do
#  by hand
# RETURN - 0 if successful, >0 otherwise
function _gitflow_release_unfinish() {
    develop_branch="$(_get_gitflow_param "branch.develop" || return 1)"
    master_branch="$(_get_gitflow_param "branch.master" || return 1)"
    release_prefix="$(_get_gitflow_param "prefix.release" || return 1)"
    version_tag="$(_get_gitflow_param "prefix.versiontag" || return 1)"

    # We DON'T want the branches to be synced here since the user should fix this manually if they are
    if _ensure_branch_sync; then
        echo "Error: master and/or develop branch have been pushed to remote; you'll need to do this manually" >&2
        return 2
    fi

    newest_master_tag="$(git describe --tags --abbrev=0 "${master_branch}")"
    if [ -z "${newest_master_tag}" ]; then
        echo "Error: No version to unrelease" >&2
        return 3
    fi

    release_branch_tip="$(git merge-base "${develop_branch}" "${master_branch}")"
    if [ -z "${release_branch_tip}" ]; then
        echo "Error: Could not find common ancestor of ${develop_branch} and ${master_branch}"
        return 4
    fi

    # If the user isn't using X.X.X-dev tags, we don't want to accidentally delete an old tag
    newest_develop_tag="$(git describe --tags --match='*-dev' --abbrev=0 "${develop_branch}")"
    if [ -z "${newest_develop_tag}" ] || [ "${newest_develop_tag%%-dev}" == "${newest_master_tag}" ]; then
        delete_develop_tag=false
    else
        delete_develop_tag=true
    fi

    newest_release_branch_name="${release_prefix}${newest_master_tag}"

    echo "To undo 'git flow release finish ${newest_master_tag##${version_tag}}' we'll:"
    echo ""
    echo " - Undo merge: ${newest_release_branch_name} => ${develop_branch}"
    echo " - Undo merge: ${newest_release_branch_name} => ${master_branch}"
    echo " - Delete tag: ${newest_master_tag} on ${master_branch}"
    if ${delete_develop_tag}; then
        echo " - Delete tag: ${newest_develop_tag} on ${develop_branch}"
    fi
    echo " - Recreate branch: ${newest_release_branch_name}"
    echo ""
    echo "We will NOT change anything on the remote!"
    echo ""
    read -p "Is this okay? ENTER for YES, Ctrl-C for NO"

    git checkout "${develop_branch}"
    git reset --hard HEAD^
    git checkout "${master_branch}"
    git reset --hard HEAD^
    git tag -d "${newest_master_tag}"
    if ${delete_develop_tag}; then
        git tag -d "${newest_develop_tag}"
    fi
    git branch "${newest_release_branch_name}" "${release_branch_tip}"
}

# TODO Idea:
# Add a "gitflow release push" command that pushes the tags and branches from the last release and
# deletes the "release/X.X.X" branch on the remote

# TODO Idea:
# When doing "gitflow release finish", autodetect the version of the release to finish

# A saner wrapper around Gitflow that:
# - auto-creates an empty commit after '_gitflow release start X.X.X' and tags it with X.X.X-rc
# - auto-creates the X.X.X-dev tag after '_gitflow release finish X.X.X'
# - allows you to undo the last release finish with '_gitflow release unfinish'
function _gitflow() {
    # If we're starting a release, make sure to push an empty commit and add the vX.X.X-rc tag
    if [ "${1}" == "release" ] && [ "${2}" == "start" ]; then
        develop_branch="$(_get_gitflow_param "branch.develop" || return 1)"
        if ! _ensure_branch_sync; then
            echo "Error: master and/or develop branch are out of sync with their remotes" >&2
            return 1
        fi
        version_tag="$(_get_gitflow_param "prefix.versiontag" || return 1)"

        # Try and autodetect the version if a user doesn't specify one
        local command="git-flow ${@}"
        if [ ${#} -eq 2 ]; then
            newest_develop_tag="$(git describe --tags --match='*-dev' --abbrev=0 "${develop_branch}")"
            minus_version_tag="${newest_develop_tag##${version_tag}}"
            version="${minus_version_tag%%-dev}"
            if [ -z "${version}" ]; then
                echo "Error: Couldn't autodetect version from latest develop branch; specify a version instead" >&2
                return 1
            fi
            read -p "What version should we release with? (${version}): " corrected_version 
            version="${corrected_version:-${version}}"
            command+=" ${version}"
        else 
            version="${!#}"
        fi
        eval "${command}" && 
            git commit --allow-empty -m "Starting release/${version}" && 
            git tag "${version}-rc"
    # If we're finishing a release, make sure to tag the develop branch with vX.X.X-dev
    elif [ "${1}" == "release" ] && [ "${2}" == "finish" ]; then
        develop_branch="$(_get_gitflow_param "branch.develop" || return 1)"
        master_branch="$(_get_gitflow_param "branch.master" || return 1)"
        if ! _ensure_branch_sync; then
            echo "Error: master and/or develop branch are out of sync with their remotes" >&2
            return 1
        fi

        # # TODO If we're on a release/ branch, autodetect the version to finish
        # # No version was specified, so try to detect it from the release branch we're on
        # if [ -z "${3}" ]; then
        #     if o
        # else
            version="${!#}"
        # fi

        git-flow "${@}" &&
            read -p "We just merged ${version}; which version is next? " next_version &&
            git checkout "${develop_branch}" &&
            git tag "${next_version}-dev"
    elif [ "${1}" == "release" ] && [ "${2}" == "unfinish" ]; then
        _gitflow_release_unfinish
    else
        git-flow "${@}"
    fi
}

alias gfl="_gitflow"

alias virtualenv="pyenv virtualenv"
