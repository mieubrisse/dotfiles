#!/usr/bin/env bash
# Shebang for syntax highlight

# ======================================================================================
#                                   Dates & Times
# ======================================================================================

# Datetime
alias today='date +%F'
alias now='date +%F_%H-%M-%S'

# ======================================================================================
#                           Upgrades for standard Unix toolkit
# ======================================================================================
#
# Allow editing Mac crontab with Vim per:
# http://superuser.com/questions/359580/error-adding-cronjobs-in-mac-os-x-lion
alias crontab="VIM_CRONTAB=true crontab"

# Better diff (Mac only)
alias diff="colordiff --ignore-space-change -u"

ls_cmd="eza"
# ls_cmd="command ls"  # Use 'command ls' to avoid accidentally fork-bombing myself. Oops...
function ls() { # Display an empty line for empty directories

    if [[ $(${ls_cmd} "${@}" | wc -l) -eq 0 ]]; then
        echo 
    else
        ${ls_cmd} -G "$@"
    fi
}

function ll() {
    # eza doesn't support ls -ltr:
    # https://github.com/eza-community/eza/issues/1573
    if [ "${ls_cmd}" = "eza" ]; then
        ${ls_cmd} -Alh --sort newest
    else
        ${ls_cmd} -Alhtr
    fi
}
alias la='ls -A'
alias l='ls'

alias cat="bat"

# du should always be human readable
alias du='du -h'

# Overwrite cd to jump up multiple levels with 'cd <# dir>..' syntax
function cd() {
    # If string isn't long enough, use builtin cd anyways
    if [[ ${#1} -lt 3 ]]; then
        builtin cd "$@"
    else
        # Check if string is in '<number>..' form
        if [[ "${1:(-2)}" == ".." ]] && [[ -n "${1%..}" ]] && [[ "${1%..}" =~ ^[0-9]+$ ]]; then
            REPEAT_TIMES="${1%..}"
            if [ "${REPEAT_TIMES}" -le 0 ]; then
                echo "Cannot do ${REPEAT_TIMES} cd's"
                return 1
            fi

            CD_STR=""
            while read; do
                CD_STR="../$CD_STR"
            done < <(seq 1 "${REPEAT_TIMES}")
            cd "$CD_STR"
        else
            builtin cd "$@"
        fi
    fi
}


# Have mkdir create parent directories if they don't already exist
alias mkdir="mkdir -p"


# Grep chain commands
alias hgr='history | gr'
alias pgr='ps aux | gr'

# Load the latest history from all tabs before modifying the history
# This allows me to see history from all tabs
# NOTE: relies on the 'history -a' in my PROMPT_COMMAND
history() {
    builtin history -n
    builtin history "${@}"
}

# Map command to open last vim session
alias vim="nvim"
alias v="vim"
alias vi="vim"
alias vimdiff="nvim -d -c 'set wrap'"

# Jobs should show PID by default
alias jobs="jobs -l"

# Easy SSH port forwarding
function sshl { 
    COMMAND="${@:2}"
    ssh -L "${1}:localhost:${1}" "${COMMAND[@]}"
}

# Command line JSON prettifier
alias prettify-json="python -mjson.tool"

# Just because it's intuitive
alias eject="diskutil unmount"


# Easily copy file contents, paths, or names to clipboard
function clip() {
    _clip_help() {
        echo "Usage: clip [OPTIONS] [file]"
        echo "       command | clip"
        echo ""
        echo "Copy file contents, paths, directories, or piped input to the clipboard."
        echo ""
        echo "Options:"
        echo "  -p    Copy the full absolute path to the file"
        echo "  -n    Copy just the filename"
        echo "  -d    Copy the current directory path"
        echo "  -h    Show this help message"
        echo "  (no option) Copy the contents of the file, or STDIN if piped"
    }

    local copy_path=false
    local copy_name=false
    local copy_dir=false

    while getopts "pndh" opt; do
        case "${opt}" in
            p)
                copy_path=true
                ;;
            n)
                copy_name=true
                ;;
            d)
                copy_dir=true
                ;;
            h)
                _clip_help
                return 0
                ;;
            *)
                echo "Unknown option: -${OPTARG}" >&2
                return 1
                ;;
        esac
    done
    shift $((OPTIND - 1))
    OPTIND=1  # Reset OPTIND for future getopts calls

    if [[ "${copy_dir}" == true ]]; then
        local current_dirpath
        current_dirpath="$(pwd)"
        echo -n "${current_dirpath}" | pbcopy
        echo "Copied directory: ${current_dirpath}"
        return 0
    fi

    if [[ ${#} -eq 0 ]]; then
        # Check if STDIN has data (not a terminal)
        if [[ ! -t 0 ]]; then
            pbcopy
            echo "Copied from STDIN"
            return 0
        fi
        _clip_help
        return 0
    fi

    if [[ "${copy_path}" == true ]] && [[ "${copy_name}" == true ]]; then
        echo "Error: Cannot use both -p and -n flags together" >&2
        return 1
    fi

    local file="${1}"

    if [[ "${copy_path}" == true ]]; then
        local abs_filepath
        abs_filepath="$(cd "$(dirname "${file}")" && pwd)/$(basename "${file}")"
        echo -n "${abs_filepath}" | pbcopy
        echo "Copied path: ${abs_filepath}"
    elif [[ "${copy_name}" == true ]]; then
        local filename
        filename="$(basename "${file}")"
        echo -n "${filename}" | pbcopy
        echo "Copied name: ${filename}"
    else
        if [[ ! -f "${file}" ]]; then
            echo "Error: File not found: ${file}" >&2
            return 1
        fi
        pbcopy < "${file}"
        echo "Copied contents of: ${file}"
    fi
}

# Adds a `chrome` command that I use for rendering Markdown files, with completion
# TODO: make this also open .sheet files in Google drive by examining the link
alias chrome="open -a 'Google Chrome'"
_chrome_completion() {
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local IFS=$'\n'
    local matches=()

    for entry in $(compgen -f -- "$cur"); do
        if [ -d "$entry" ]; then
            matches+=("${entry}/")
        elif echo "$entry" | grep -q '\.md$'; then
            matches+=("$entry")
        elif echo "$entry" | grep -q '\.html$'; then
            matches+=("$entry")
        fi
    done

    COMPREPLY=("${matches[@]}")

    # Prevent trailing space after completion so directories can be drilled into
    if [ ${#COMPREPLY[@]} -eq 1 ] && echo "${COMPREPLY[0]}" | grep -q '/$'; then
        compopt -o nospace
    fi
}
complete -F _chrome_completion chrome # Allow completion of Markdown files, and directories that might have Markdown files

function 1p() {
    # TODO If no arguments are provided, let's do some fzf magic
    op "${@}"
    return "${?}"
}
complete -o default -F __start_op 1p  # We hijack 1Password's completion for our alias

function replace() {
    needle="${1:-}"
    replacement="${2:-}"
    filename_regex="${3:-}"

    if [ -z "${needle}" ]; then
        echo "Error: First argument must be a string to find" >&2
        return 1
    fi
    if [ -z "${replacement}" ]; then
        echo "Error: Second argument must be a string to replace found patterns with" >&2
        return 1
    fi
    if [ -z "${filename_regex}" ]; then
        echo "Error: Third argument must be a 'find'-compatible regex of filenames to match" >&2
        return 1
    fi

    local DELETE_SUFFIX=".deleteme"
    sed -i"${DELETE_SUFFIX}" "s?${needle}?${replacement}?g" $(find . -name "${filename_regex}")
    find . -name "*${DELETE_SUFFIX}" -delete
}

# ======================================================================================
#                                   Searching & Navigating
# ======================================================================================
alias csgr='grep -I --color=auto'    # Case-sensitive grep
alias gr='csgr -i'
alias csegr='grep -I --color=auto' # Case-sensitive egrep
alias egr='csegr -i'
alias fgrep='fgrep --color=auto'
alias egrep='egrep --color=auto'
function rgr() { gr --exclude-dir="." --exclude-dir=".." -r "$@" ./* ./.*; }
function csrgr() { csgr --exclude-dir="." --exclude-dir=".." -r "$@" ./* ./.*; }  # Case-sensitive recursive grep
function ergr() { egr --exclude-dir="." --exclude-dir=".." -r "$@" ./* ./.*; }
function csergr() { csegr --exclude-dir="." --exclude-dir=".." -r "$@" ./* ./.*; }  # Case-sensitive recursive egrep

# Given a file, detects what type it is and:
# 1) cd's to it if it's a directory
# 2) opens it in Vim if it's a text file
# 3) throws an error if it's a binary file
function smart_open {
    filepath="${1}"
    if ! [ -e "${filepath}" ]; then
        echo "Error: No such file at '${filepath}'" >&2
        return 1
    fi

    # TODO Handle multiple input files (probably using fzf, or something like cmdk)
    mime_type="$(file -b --mime-type "${filepath}")"
    program=""
    case "${mime_type}" in
        text/*)
            program="vim"
            ;;
        application/json)
            program="vim"
            ;;
        inode/directory)
            program="cd"
            ;;
        application/pdf)
            program="open"
            ;;
        application/vnd.openxmlformats-officedocument.wordprocessingml.document)
            program="open"
            ;;
        image/*)
            program="open"
            ;;
        *)
            echo "Error: Unknown MIME type: ${mime_type}" >&2
            return 1
            ;;
    esac
    "${program}" "${filepath}"
}
alias so="smart_open"

# TODO Idea:
# Fuzzy_find and fuzzy_ls can take an additional argument of the directory to search!

# Make find not suck, and exclude some sensible defaults (which I hope don't come back to bite me one day...)
alias cif="find . ! -name '*.class' -and -iname" # Case-insensitive find
function fuzzy_find() { 
    ARGS="${@}"
    ARGS="${ARGS%%/}"  # Remove trailing slash so we can find directories by name
    cif "*${ARGS// /*}*"
}
function fuzzy_ls() {
    ARGS="${@}"
    ARGS="${ARGS%%/}"  # Remove trailing slash so we can find directories by name
    cif "*${ARGS// /*}*" -maxdepth 1
}
alias ff="fuzzy_find"
alias fl="fuzzy_ls"

# Allows user to choose which lines of piped input to pass through
alias filter="${HOME}/.bash_utils/filter.py"

# Pipes the output of the given command to filter
function _pipe_to_filter() {
    "${@}" | filter
}
alias fff="_pipe_to_filter fuzzy_find"

# Fuzzy searches for the given file, then filters output and feeds it into the given command
# $1 - Command to feed chosen file to
# $2 - Command to generate results for filtering
# $3+ - Arguments passed to command for generating results to filter
function use_command_filter_results() {
    # Unquoted word-splitting is intentional here
    ${1} $(${2} "${@:3}" | filter)
}

alias vff="use_command_filter_results 'vim -O' fuzzy_find"
alias vfl="use_command_filter_results 'vim -O' fuzzy_ls"
alias sff="use_command_filter_results 'smart_open' fuzzy_find"
alias sfl="use_command_filter_results 'smart_open' fuzzy_ls"

# $1 - arguments to pass to ls
# $2 - function to use to sort ls results (head|tail)
# $3 - number of results to ask for from head/tail
function _ls_results {
    ls "$1" | "$2" -n "$3"
}

# TODO Idea:
# "newest", "oldest", etc. can also take in a path to search for files on, perhaps? E.g. "newest 3 ~/Downloads*.par" says
# "Find the newest 3 files in ~/Downloads.par"

# Returns the __ most-recently-modified files
function newest {
    if [[ $# -eq 0 ]]; then
        NUM_RESULTS=1
    else
        NUM_RESULTS=$1
    fi
    _ls_results '-tr' 'tail' "$NUM_RESULTS"
}
alias latest="newest"

# Returns the __ least-recently-modified files
function oldest {
    if [[ $# -eq 0 ]]; then
        NUM_RESULTS=1
    else
        NUM_RESULTS=$1
    fi
    _ls_results '-tr' 'head' "$NUM_RESULTS"
}
alias earliest="oldest"

# Returns the __ first files alphabetically from ls
function first {
    if [[ $# -eq 0 ]]; then
        NUM_RESULTS=1
    else
        NUM_RESULTS=$1
    fi
    _ls_results '' 'head' "$NUM_RESULTS"
}

# Returns the __ last files alphabetically from ls
function last {
    if [[ $# -eq 0 ]]; then
        NUM_RESULTS=1
    else
        NUM_RESULTS=$1
    fi
    _ls_results '' 'tail' "$NUM_RESULTS"
}

# Returns the __ biggest files by filesize
function biggest {
    if [[ $# -eq 0 ]]; then
        NUM_RESULTS=1
    else
        NUM_RESULTS=$1
    fi
    _ls_results '-Sr' 'head' "$NUM_RESULTS"
}

# Returns the __ smallest files by filesize
function smallest {
    if [[ $# -eq 0 ]]; then
        NUM_RESULTS=1
    else
        NUM_RESULTS=$1
    fi
    _ls_results '-Sr' 'tail' "$NUM_RESULTS"
}

# ======================================================================================
#                                            Vim 
# ======================================================================================
alias sp="vim -o"
alias vsp="vim -O"

# ======================================================================================
#                                      Git
# ======================================================================================

alias lg=lazygit

# Viewing changes
alias gs="git status -sb"
alias gsh="git show"
alias gd="git diff"
alias gdc="gd --cached"
alias gl="git log --graph --abbrev-commit --decorate --date=relative --format=format:'%C(bold blue)%h%C(reset) - %C(bold green)(%ar)%C(reset) %C(white)%s%C(reset) %C(bold black)[%an]%C(reset)%C(bold yellow)%d%C(reset)' --all"

# Making changes
alias gb="git branch"
function gco {
    if [ "${#}" -ne 0 ]; then
        git checkout "${@}"
        return "${?}"
    fi

    # Use fzf to select branches from most-recent-branches if no args are provided
    tmpfile=$(mktemp)
    tmpfile_all="${tmpfile}.all"
    tmpfile_sorted="${tmpfile}.sorted"
    tmpfile_deduped="$(mktemp)"

    # Step 1: generate triples of (full_branch_name,short_branch_name,timestamp) for local & remote branches
    {
        git for-each-ref --format='%(refname:short),%(refname:short),%(committerdate:unix)' refs/heads/

        git for-each-ref --format='%(refname:short),%(committerdate:unix)' refs/remotes/ | \
            awk -F',' '{
                full = $1;
                gsub(/^origin\//, "", $1);
                print full "," $1 "," $2
            }'
    } > "${tmpfile_all}"

    # Step 2: sort by short branch name to put local & remote branch lines next to each other
    sort -t',' -k2,2 -k3,3nr "${tmpfile_all}" > "${tmpfile_sorted}"

    # Step 3: dedupe by short_name, preferring the local row if it's present
    # TODO hardcodes 'origin', which might be a problem at some point in the distant future
    awk -F',' '
    {
        full = $1; short = $2; ts = $3
        is_remote = (full ~ /^origin\//)
        if (!(short in seen) || (!is_remote && source[short] == "remote")) {
            seen[short] = full "," short "," ts
            source[short] = is_remote ? "remote" : "local"
        }
    }
    END {
        for (s in seen) print seen[s]
    }
' "${tmpfile_sorted}" > "${tmpfile_deduped}"

    rm "${tmpfile_all}" "${tmpfile_sorted}"

    # Step 4: final sort by timestamp descending
    sort -t',' -k3,3nr "${tmpfile_deduped}" | cut -d',' -f1 | fzf --bind='enter:become(git checkout {})'

    rm "${tmpfile_deduped}" # Not THAT important if this doesn't run (since it's a tempfile, and a small one)
}

# Same as 'gco', except does a stash & stash pop
gcos() {
    git stash
    echo "üì• STASHED CHANGES"
    gco "${@}"

    # Intentionally not checking the error code of "gco", so that the stash goes
    git stash pop
    echo "üì§ UNSTASHED CHANGES"
}

ga() {   # Use fzf to select files if no arguments are provided
    if [ $# -eq 0 ]; then
        local candidates
        candidates=$(git status --porcelain | grep '^[ MARC][ MD]' | cut -c4-)

        if [ -z "$candidates" ]; then
            echo "Working directory clean; no files to add."
            return
        fi

        local selection
        selection=$(echo -e "[ALL]\n$candidates" | fzf -m --prompt="Add files: " \
            --preview='[[ {} != "[ALL]" ]] && git diff --color=always -- {} | diff-so-fancy || echo "Stage all modified files"')

        if [[ "$selection" == *"[ALL]"* ]]; then
            echo "$candidates" | xargs git add --
        elif [ -n "$selection" ]; then
            echo "$selection" | xargs git add --
        fi
    else
        git add "$@"
    fi
}

# We hijack Git's autocomplete here so we get autocompletion on our custom aliases
# This relies on the bash-completion Homebrew package being loaded before this runs
if command -v __git_complete > /dev/null; then
    __git_complete gco _git_checkout
    __git_complete gb _git_branch
fi

alias gcm="git commit -m"
alias gg="git commit -am"

grs() {    # Use fzf to select files to reset if no arguments are provided
    if [ $# -eq 0 ]; then
        local candidates
        candidates=$(git status --porcelain | grep '^[ MARC][ MD]' | cut -c4-)

        if [ -z "$candidates" ]; then
            echo "Working directory clean; no files to unstage."
            return
        fi

        local selection
        selection=$(echo -e "[ALL]\n$candidates" | fzf -m --prompt="Reset files: ")

        if [[ "$selection" == *"[ALL]"* ]]; then
            echo "$candidates" | xargs git reset --
        elif [ -n "$selection" ]; then
            echo "$selection" | xargs git reset --
        fi
    else
        git reset "$@"
    fi
}
alias grs1="git reset --soft HEAD^"

# Dealing with remotes
function gcl() {
    if [[ $# -eq 0 ]]; then
        local selection
        selection="$(gh repo list --limit 100 --json nameWithOwner --jq '.[].nameWithOwner' | fzf --reverse)"
        if [[ -n "${selection}" ]]; then
            git clone "https://github.com/${selection}.git"
        fi
    else
        git clone "$@"
    fi
}
alias gf="git fetch --prune"
alias gpl="git pull"
function gp() {	# Push the branch upstream if it doesn't exist; otherwise just git push
	BRANCH_NAME="$(git rev-parse --abbrev-ref HEAD)"
	if [[ $(git config "branch.$BRANCH_NAME.merge") == '' ]]; then
            git push -u origin "$BRANCH_NAME" "$@"
        else
            git push "$@"
        fi
}
alias gprune-local-dry-run="git branch --merged | grep -v '\*' | grep -v 'master' | grep -v 'develop'"
alias gprune-local="git branch --merged | grep -v '\*' | grep -v 'master' | grep -v 'develop' | xargs -n 1 git branch -d"

# ======================================================================================
#                                      Github
# ======================================================================================
alias ghi="bash ${HOME}/.bash_utils/gh-issue-create.sh"

# ======================================================================================
#                                      Gradle
# ======================================================================================
# Searches for a gradlew file up the tree and uses it for gradle commands
# Add 'nocd' as the first argument to run the gradle commands from the directory you're in at the moment
function gradle_search() {
    ORIG_DIR="$PWD"
    while [[ "$PWD" != "/" ]]; do
        if [[ -f "./gradlew" ]]; then
            if [[ "$1" == "nocd" ]]; then
                GRADLE_DIR=$(pwd)
                cd "$ORIG_DIR"
                echo "$GRADLE_DIR"/gradlew "${@:2}"
                "$GRADLE_DIR"/gradlew "${@:2}"
            else
                ./gradlew --daemon "$@"
                cd "$ORIG_DIR"
            fi
            return 0
        else
            cd ..
        fi
    done
    cd "${ORIG_DIR}"
    echo "No gradlew file found in any parent directories" >&2
}
alias grd="gradle_search"

alias rsync="rsync --perms --progress"

# Easy SSH aliases
# Interesting tidbit: I used to have a 'for line in $(grep '^Host.....)' thing here, but 
# one of my HostName entries in my SSH config file was '*', which was getting Bash glob-expanded and causing problems!
# Lesson learned...
grep '^Host' "${HOME}/.ssh/config" | grep -v '[*]' | awk '{print $2}' | while read -r ssh_host; do
    alias "${ssh_host}"="ssh '${ssh_host}'"
done

alias virtualenv="pyenv virtualenv"

# Make following a file much easier
alias lsf="less +F"

# ======================================================================================
#                                      Navigation
# ======================================================================================

# Call this script and pass a text file with a list of servers. You will ssh to the servers as the current user.
# Once connected use Ctrl + a to enter commands
# de/syncronize panes = Ctrl + a + s
# Change panes = Ctrl + a + arrow-keys
# Zoom into pane = Ctrl + a + z
function parallel-tmux() {
    tmux new-session -s $(date +"%F_%H-%M-%S") -d
    count=-1
    for i in $(cat $1); do
      let count=${count}+1
      if [ $count -eq 0 ]; then
        tmux new-window "ssh $i"
      else
        tmux split-window -h "ssh $i"
        tmux select-layout tiled
      fi
    done
    tmux set-window-option synchronize-panes on
    tmux attach
}

# Workspace session configuration
_workspace_session_name="workspace"

# Directory paths needed by workspace (defined here to ensure availability)
code_dirpath="${HOME}/code"
dotfiles_dirpath="${HOME}/app/dotfiles"
ai_factory_dirpath="${code_dirpath}/ai-work-factory"
lifeops_dirpath="${code_dirpath}/lifeops-toolkit"

# Window configuration: "type<tab>name<tab>working_dir<tab>command"
# Special entry: "pane" type creates a vertical split in the previous window
_workspace_get_windows() {
    # Dotfiles
    printf '%s\t%s\t%s\t%s\n' "window" "üõ†Ô∏è  dotfiles" "${dotfiles_dirpath}" ""
    printf '%s\t%s\t%s\t%s\n' "pane" "-" "${dotfiles_dirpath}" "claude -c"

    # Lifeops
    printf '%s\t%s\t%s\t%s\n' "window" "üéì lifeops" "${lifeops_dirpath}" ""
    printf '%s\t%s\t%s\t%s\n' "pane" "-" "${lifeops_dirpath}" "claude -c"

    # AI factory
    printf '%s\t%s\t%s\t%s\n' "window" "üè≠ ai-factory" "${ai_factory_dirpath}" ""
    printf '%s\t%s\t%s\t%s\n' "pane" "-" "${ai_factory_dirpath}" "claude -c"

    # Calendar Manager
    printf '%s\t%s\t%s\t%s\n' "window" "üóìÔ∏è  calendar" "${ai_factory_dirpath}/calendar-manager" "claude -c"

    # Todoist Manager
    printf '%s\t%s\t%s\t%s\n' "window" "‚úÖ todoist" "${ai_factory_dirpath}/todoist-manager" "claude -c"

    # Researcher
    printf '%s\t%s\t%s\t%s\n' "window" "üîç researcher" "${ai_factory_dirpath}/researcher" "claude -c"
}

# Get list of Claude window names
_workspace_get_claude_window_names() {
    while IFS=$'\t' read -r entry_type name working_dir full_cmd; do
        if [ "${entry_type}" = "window" ] && [[ "${full_cmd}" == claude* ]]; then
            echo "${name}"
        fi
    done < <(_workspace_get_windows)
}

# Upgrade Claude in all workspace windows
_workspace_upgrade() {
    if ! tmux has-session -t "${_workspace_session_name}" 2>/dev/null; then
        echo "No workspace session found"
        return 1
    fi

    echo "Closing Claude windows..."
    while read -r window; do
        tmux kill-window -t "${_workspace_session_name}:${window}" 2>/dev/null || true
    done < <(_workspace_get_claude_window_names)

    echo "Upgrading claude-code..."
    brew upgrade claude-code

    echo "Reopening Claude windows..."
    local idx=0
    local current_window=""
    while IFS=$'\t' read -r entry_type name working_dir full_cmd; do
        if [ "${entry_type}" = "window" ]; then
            ((idx++))
            current_window="${name}"
            if [[ "${full_cmd}" == claude* ]]; then
                tmux new-window -t "${_workspace_session_name}:${idx}" -n "${name}" -c "${working_dir}"
                tmux set-window-option -t "${_workspace_session_name}:${name}" automatic-rename off
                tmux send-keys -t "${_workspace_session_name}:${name}" "${full_cmd}" Enter
            fi
        elif [ "${entry_type}" = "pane" ] && [[ "${full_cmd}" == claude* ]]; then
            # Add pane to current window
            tmux split-window -h -c "${working_dir}" -t "${_workspace_session_name}:${current_window}"
            tmux send-keys -t "${_workspace_session_name}:${current_window}.1" "${full_cmd}" Enter
        fi
    done < <(_workspace_get_windows)

    echo "Upgrade complete"
}

work() {
    local action="attach"

    # Parse flags
    while getopts "ureh" opt; do
        case "${opt}" in
            u)
                action="upgrade"
                ;;
            r)
                action="restart"
                ;;
            e)
                action="exit"
                ;;
            h)
                echo "Usage: work [-u|-r|-e|-h]"
                echo "  (no args)  Create or attach to workspace"
                echo "  -u         Upgrade Claude in all windows"
                echo "  -r         Restart: exit, reload aliases, and re-enter"
                echo "  -e         Exit workspace session"
                echo "  -h         Show this help"
                return 0
                ;;
            *)
                echo "Usage: work [-u|-r|-e|-h]" >&2
                return 1
                ;;
        esac
    done
    shift $((OPTIND - 1))
    OPTIND=1  # Reset for future getopts calls

    # Handle upgrade
    if [ "${action}" = "upgrade" ]; then
        _workspace_upgrade
        return $?
    fi

    # Handle restart
    if [ "${action}" = "restart" ]; then
        work -e
        source "${HOME}/.bash_aliases"
        work
        return $?
    fi

    # Handle exit
    if [ "${action}" = "exit" ]; then
        if ! tmux has-session -t "${_workspace_session_name}" 2>/dev/null; then
            echo "No workspace session found"
            return 1
        fi
        # tmux kill-session sends SIGHUP to all process groups in the session
        # With 'set noswapfile' in vimrc, Vim exits cleanly without leaving .swp files
        tmux kill-session -t "${_workspace_session_name}"
        echo "Workspace session closed"
        # Reload bash aliases in case they were modified during the session
        source "${HOME}/.bash_aliases"
        echo "Bash aliases reloaded"
        return 0
    fi

    # Default: attach to the session if it exists
    if tmux has-session -t "${_workspace_session_name}" 2>/dev/null; then
        if [ -n "${TMUX}" ]; then
            tmux switch-client -t "${_workspace_session_name}"
        else
            tmux attach-session -t "${_workspace_session_name}"
        fi
        return 0
    fi

    # Pre-authenticate with 1Password before creating tmux session
    # Biometric auth doesn't work properly inside tmux, so do it here first
    echo "Authenticating with 1Password..."
    if ! op whoami &>/dev/null; then
        echo "WARNING: Could not pre-authenticate with 1Password"
        echo "You may need to authenticate manually in each window"
    fi

    # Read first window config
    local first_entry_type first_name first_dir first_cmd
    IFS=$'\t' read -r first_entry_type first_name first_dir first_cmd < <(_workspace_get_windows | head -1)

    # Create session with first window already configured (avoids default bash window)
    tmux new-session -d -s "${_workspace_session_name}" -n "${first_name}" -c "${first_dir}"
    tmux set-window-option -t "${_workspace_session_name}:${first_name}" automatic-rename off
    tmux send-keys -t "${_workspace_session_name}:${first_name}" "${first_cmd}" Enter

    # Create remaining windows and panes
    local current_window="${first_name}"
    while IFS=$'\t' read -r entry_type name working_dir full_cmd; do
        if [ "${entry_type}" = "window" ]; then
            current_window="${name}"
            tmux new-window -t "${_workspace_session_name}" -n "${name}" -c "${working_dir}"
            tmux set-window-option -t "${_workspace_session_name}:${name}" automatic-rename off
            tmux send-keys -t "${_workspace_session_name}:${name}" "${full_cmd}" Enter
        elif [ "${entry_type}" = "pane" ]; then
            # Split the current window horizontally (side-by-side panes)
            tmux split-window -h -c "${working_dir}" -t "${_workspace_session_name}:${current_window}"
            tmux send-keys -t "${_workspace_session_name}:${current_window}.1" "${full_cmd}" Enter
        fi
    done < <(_workspace_get_windows | tail -n +2)

    # Select the first window and attach
    tmux select-window -t "${_workspace_session_name}:${first_name}"
    if [ -n "${TMUX}" ]; then
        tmux switch-client -t "${_workspace_session_name}"
    else
        tmux attach-session -t "${_workspace_session_name}"
    fi
}


# ======================================================================================
#                                      Navigation
# ======================================================================================

# Helper function that selects a subdirectory from a parent directory using fzf-style matching.
# If query terms match exactly one directory, it's auto-selected. Otherwise, fzf is shown.
#
# Arguments:
#   $1 - Parent directory path to search in
#   $2+ - Query terms (spaces become wildcards in glob matching)
#
# Returns: Selected directory basename printed to stdout, or empty string if none selected
_fzf_select_subdir() {
    local parent_dirpath="${1}"
    shift
    local query_terms="${*}"

    if [ ! -d "${parent_dirpath}" ]; then
        echo "Error: Directory not found at '${parent_dirpath}'" >&2
        return 1
    fi

    local selected_dirname=""

    if [ -n "${query_terms}" ]; then
        local glob_query="*${query_terms// /*}*"
        local dirs_matching_glob
        dirs_matching_glob="$(find "${parent_dirpath}" -maxdepth 1 -type d ! -path "${parent_dirpath}" -iname "${glob_query}" -exec basename {} \;)"
        local num_matches
        num_matches="$(echo -n "${dirs_matching_glob}" | grep -c '^')"

        # If we only have one match, select it automatically
        if [ "${num_matches}" -eq 1 ]; then
            selected_dirname="${dirs_matching_glob}"
        fi
    fi

    # If no auto-selection, use fzf
    if [ -z "${selected_dirname}" ]; then
        selected_dirname="$(
            find "${parent_dirpath}" -maxdepth 1 -type d ! -path "${parent_dirpath}" -exec basename {} \; | \
            sort | \
            fzf --query="${query_terms}"
        )"
    fi

    echo "${selected_dirname}"
}

# TODO replace this with all fzf stuff
function _smart_open_dir_file {
    cd "${2}"
    if [ "${#}" -gt 2 ]; then
        use_command_filter_results 'smart_open' "${1}" "${@:3}"
    fi
}

dotfiles_dirpath="${HOME}/app/dotfiles"
alias dotfiles="cd '${dotfiles_dirpath}'"

code_dirpath="${HOME}/code"

# Alias for jumping around code directories
# If no arguments are specified, then we go directly to the code directory
# If any number of arguments are specified, they're treated as search terms and...
# - If one directory matches, we go directly to it
# - If more than one directory matches, we open fzf to filter the results
function code() {
    if [ "${#}" -eq 0 ]; then
        cd "${code_dirpath}"
        return 0
    fi

    local selected_dirname
    selected_dirname="$(_fzf_select_subdir "${code_dirpath}" "${@}")"

    if [ -z "${selected_dirname}" ]; then
        return 0
    fi

    cd "${code_dirpath}/${selected_dirname}"
}

writing_dirpath="${code_dirpath}/personal-writing"
alias pwriting="cd ${writing_dirpath}"   # TODO upgrade this to take in a search term and optionally 'cd' to that

# Start or attach to the 'deepwork' tmux session for personal writing
deepwork() {
    local session_name="deepwork"
    local action="attach"

    # Parse flags
    while getopts "reh" opt; do
        case "${opt}" in
            r)
                action="restart"
                ;;
            e)
                action="exit"
                ;;
            h)
                echo "Usage: deepwork [-r|-e|-h]"
                echo "  (no args)  Create or attach to deepwork session"
                echo "  -r         Restart: exit, reload aliases, and re-enter"
                echo "  -e         Exit deepwork session"
                echo "  -h         Show this help"
                return 0
                ;;
            *)
                echo "Usage: deepwork [-r|-e|-h]" >&2
                return 1
                ;;
        esac
    done
    shift $((OPTIND - 1))
    OPTIND=1  # Reset for future getopts calls

    # Handle restart
    if [ "${action}" = "restart" ]; then
        deepwork -e
        source "${HOME}/.bash_aliases"
        deepwork
        return $?
    fi

    # Handle exit
    if [ "${action}" = "exit" ]; then
        if ! tmux has-session -t "${session_name}" 2>/dev/null; then
            echo "No deepwork session found"
            return 1
        fi
        tmux kill-session -t "${session_name}"
        echo "Deepwork session closed"
        source "${HOME}/.bash_aliases"
        echo "Bash aliases reloaded"
        return 0
    fi

    # Default: attach if session already exists
    if tmux has-session -t "${session_name}" 2>/dev/null; then
        if [ -n "${TMUX}" ]; then
            tmux switch-client -t "${session_name}"
        else
            tmux attach-session -t "${session_name}"
        fi
        return 0
    fi

    # Create new session with window in writing directory
    tmux new-session -d -s "${session_name}" -c "${writing_dirpath}"
    tmux set-window-option -t "${session_name}" automatic-rename off

    # Attach to the new session
    if [ -n "${TMUX}" ]; then
        tmux switch-client -t "${session_name}"
    else
        tmux attach-session -t "${session_name}"
    fi
}

downloads_dirpath="${HOME}/Downloads"
alias downloads="_smart_open_dir_file fuzzy_ls '${downloads_dirpath}'"

gdrive_dirpath="${HOME}/gdrive"
alias gdrive="_smart_open_dir_file fuzzy_ls '${gdrive_dirpath}'"

check_dirpath="${gdrive_dirpath}/checklists-and-templates"
alias check="_smart_open_dir_file fuzzy_find '${check_dirpath}'"

# Create a file from a template
template() {
    local dest_filepath="${1:-}"
    local template_filepath="${2:-}"

    if [ -z "${dest_filepath}" ]; then
        echo "Usage: template <dest_filepath> [template_filepath]" >&2
        return 1
    fi

    # If no template provided, use fzf to select one
    if [ -z "${template_filepath}" ]; then
        template_filepath=$(fd -t f -t l -E ARCHIVE . "${check_dirpath}" | fzf --prompt="Select template: ")

        if [ -z "${template_filepath}" ]; then
            echo "No template selected" >&2
            return 1
        fi
    fi

    if [ ! -f "${template_filepath}" ]; then
        echo "Error: Template not found: ${template_filepath}" >&2
        return 1
    fi

    cp "${template_filepath}" "${dest_filepath}"
    echo "Created ${dest_filepath} from template"
}

gref_dirpath="${gdrive_dirpath}/general-reference"
alias gref="_smart_open_dir_file fuzzy_find '${gref_dirpath}'"

receipts_dirpath="${gdrive_dirpath}/receipts-records-confirmations"
alias receipts="_smart_open_dir_file fuzzy_find '${receipts_dirpath}'"

psup_dirpath="${gdrive_dirpath}/project-support"
alias psup="_smart_open_dir_file fuzzy_ls '${psup_dirpath}'"

someday_dirpath="${gdrive_dirpath}/someday-maybe"
alias someday="_smart_open_dir_file fuzzy_find '${someday_dirpath}'"

self_improvement_dirpath="${gref_dirpath}/self-improvement"
alias selfimprovement="_smart_open_dir_file fuzzy_find '${self_improvement_dirpath}'"

work_gdrive_dirpath="${HOME}/work-gdrive"
alias work-gdrive="_smart_open_dir_file fuzzy_ls '${work_gdrive_dirpath}'"

alias til="vim ${gref_dirpath}/today-i-learned.md"

alias tmp="cd /tmp"

alias baliases="vim ${HOME}/.bash_aliases"
alias vimrc="vim ${HOME}/.vimrc"
alias bashrc="vim ${HOME}/.bashrc"

alias home="cd ${HOME}"

ai_factory_dirpath="${code_dirpath}/ai-work-factory"


# ======================================================================================
#                                      AI Factory
# ======================================================================================
af() {
    if [ "${#}" -eq 0 ]; then
        cd "${ai_factory_dirpath}"
        return
    fi

    local selected_dirname
    selected_dirname="$(_fzf_select_subdir "${ai_factory_dirpath}" "${@}")" || return 1

    if [ -z "${selected_dirname}" ]; then
        return 0
    fi

    cd "${ai_factory_dirpath}/${selected_dirname}"
    claude -c
}

# ======================================================================================
#                                      Docker
# ======================================================================================
clear_containers() {
    docker rm $(docker stop $(docker ps -a --quiet --format="{{.ID}}"))
}
alias cclear=clear_containers
function volume_exec() {
    volume_name="${1}"
    shift 1

    volume_path="$(docker volume inspect "${volume_name}" | grep 'Mountpoint' | awk '{print $2}' | sed 's/"\(.*\)",/\1/g')"
    full_volume_path="/docker${volume_path}"

    num_args="${#}"
    penultimate_arg_index="$((num_args - 1))"

    path_inside_volume="${1}"
    if [ "${num_args}" -gt 1 ]; then
        set -- "${@:1:${penultimate_arg_index}}" "${full_volume_path}/${@:${num_args}}"
    else
        set -- "${full_volume_path}/${@:${num_args}}"
    fi

    docker run --rm -it -v /:/docker alpine:edge "${@}"
}

clear_old_images() {
    docker image rm $(docker images --quiet --filter "dangling=true")
}
alias iclear=clear_old_images



# ======================================================================================
#                                      Kubernetes
# ======================================================================================
alias k8s="kubectl"


# ======================================================================================
#                                      Kurtosis
# ======================================================================================
# Alias 'kt' to 'kurtosis'
alias kt="kurtosis"
complete -F __start_kurtosis kt

# Alias 'kt' to the dev version of Kurtosis
alias ktdev="${code_dirpath}/kurtosis-monorepo/cli/cli/scripts/launch-cli.sh"

# ======================================================================================
#                                      Python
# ======================================================================================
alias python="python3"


# ======================================================================================
#                                  ffmpeg + gifsicle
# ======================================================================================
function gifinate() {
    if [ "${#}" -ne "2" ]; then
        echo "Usage: gifinate input_filepath output_size" >&2
        echo "Note that size will be in WxH format" >&2
        return 1
    fi
    input_filepath="${1}"
    output_size="${2}"

    if [ "${input_filepath%%.mov}" = "${input_filepath}" ]; then
        echo "Error: Input filepath must be a .mov" >&2
        return 1
    fi

    ffmpeg -i "${input_filepath}" -s "${output_size}" -pix_fmt rgb24 -r 15 -f gif - | gifsicle --optimize=3 --delay=3 > "${input_filepath}.gif"
}



# ======================================================================================
#                                  Custom-Built Apps
# ======================================================================================
# Wealthdraft aliases
function wealthdraft() {
    binary_dirpath="/wealthdraft"
    configs_dirpath="/config"
    docker run --rm \
        -v "${code_dirpath}/wealthdraft-personal-configs:${configs_dirpath}" \
        -v "${HOME}/app/wealthdraft:${binary_dirpath}" \
        amazoncorretto:11-alpine \
        sh -c "java -jar ${binary_dirpath}/*.jar \
            --gov-constants ${configs_dirpath}/gov-constants.yml \
            --scenarios ${configs_dirpath}/scenarios.yml \
            --assets ${configs_dirpath}/assets.yml \
            --assets-history ${configs_dirpath}/assets-history.yml \
            --projections ${configs_dirpath}/projections.yml \
            --asset-allocations ${configs_dirpath}/asset-allocations.yml \
            --filters ${configs_dirpath}/filters.yml \
            --all"

}


# ======================================================================================
#                                    CLI Journal
# ======================================================================================
export journal_dirpath="${gdrive_dirpath}/journal"   # Must be exported so fzf can use this

alias journal="cd ${journal_dirpath}"

# Helper function to sanitize journal names from arguments
_sanitize_journal_name() {
    local joined_name="${*}"
    local sanitized_name="${joined_name// /-}"
    
    # Remove .md extension if present
    sanitized_name="${sanitized_name%.md}"
    
    # Check if empty after sanitization
    if [ -z "${sanitized_name}" ]; then
        return 1
    fi
    
    echo "${sanitized_name}"
}

# Builds a list of the files in the CLI journal, for use with fzf
_fzf_journal_find_cmd() {
    fd -e md -t f . "${journal_dirpath}" |                                   # list *.md only
    awk -v OFS=$'\t' '
    BEGIN {
        grey  = "\033[90m"   # dark-grey (bright black)
        yellow= "\033[33m"
        reset = "\033[0m"
    }
    {
        path = $0
        file = $0
        sub(/.*\//, "", file)     # strip leading dirs
        sub(/\.md$/, "", file)    # strip .md

        n      = split(file, parts, "~")
        entry  = parts[1]                       # FIRST
        tsraw  = (n>=2 ? parts[2] : "")         # SECOND  YYYY-MM-DD_HH-mm-SS

        split(tsraw, t, "_")
        gsub(/-/, ":", t[2])                    # HH-mm-SS ‚Üí HH:mm:SS
        tspretty = t[1] " " t[2]                # YYYY-MM-DD HH:mm:SS

        # columns: 1=path, 2=coloured timestamp, 3=plain entry, 4=raw timestamp
        print path, yellow tspretty reset, entry, tsraw
    }' |
    sort -t $'\t' -k4,4r
}
export -f _fzf_journal_find_cmd  # Need to export this so fzf can use it

# This is a helper function for creating files from templates.
#
# It will open a buffer in Vim with the template contents, ready to write to the desired destination.
# Saving will only happen when the user does ':w', however.
#
# This function will also:
# - Transform any lines in the template with <!-- mark:x --> into an actual mark 'x' (or 'a', or whatever)
# - Load the 'w' register with the string 'WHY: ' for doing 'why' reflection (see https://github.com/mieubrisse/lifeops-toolkit/blob/main/reflection.md )
# - Load the 'e' register with a macro ready to create a newline with a nested 'WHY: ' bulletpoint
_open_file_from_template_without_writing() {
    local template="${1}"
    local filepath="${2}"

    # Process template content: replace <!-- mark:x --> lines with empty lines and generate vim mark commands
    local vim_mark_commands=()
    local processed_content=""
    local line_number=1
    
    while IFS= read -r line; do
        if [[ "${line}" =~ ^\<!--[[:space:]]*mark:([a-zA-Z])[[:space:]]*--\>$ ]]; then
            # Extract the mark letter
            local mark_letter="${BASH_REMATCH[1]}"
            # Replace the mark line with an empty line
            processed_content+=$'\n'
            # Add vim command to set the mark on this line
            vim_mark_commands+=("-c" "${line_number}mark ${mark_letter}")
        else
            processed_content+="${line}"$'\n'
        fi
        ((line_number++))
    done < "${template}"

    # NOTE: breaks if 'filepath' has spaces
    printf '%s' "${processed_content}" | vim -n -i NONE \
        -c "setlocal noundofile noswapfile" \
        -c "setlocal filetype=markdown" \
        -c "file ${filepath}" \
        -c "call setreg('w', 'WHY: ')" \
        -c "call setreg('e', 'o    - WHY: ')" \
        "${vim_mark_commands[@]}"
}

# Create a new journal entry
jn() {
    local sanitized_name
    if ! sanitized_name=$(_sanitize_journal_name "${@}"); then
        echo "Error: Provide name for journal entry: jn [name_fragments...]" >&2
        return 1
    fi

    local filepath="${journal_dirpath}/${sanitized_name}~$(now)~.md"
    vim "${filepath}"
}

# Create a new journal entry with a symlink in the current directory
jnl() {
    local sanitized_name
    if ! sanitized_name=$(_sanitize_journal_name "${@}"); then
        echo "Error: Provide name for journal entry: jnl [name_fragments...]" >&2
        return 1
    fi

    local journal_filepath="${journal_dirpath}/${sanitized_name}~$(now)~.md"
    local symlink_filepath="${sanitized_name}.md"

    # Create the symlink before opening vim
    ln -sf "${journal_filepath}" "${symlink_filepath}"

    # Open vim for the journal entry
    vim "${journal_filepath}"

    # If the user quit without writing, clean up the symlink
    if [ ! -f "${journal_filepath}" ]; then
        rm -f "${symlink_filepath}"
    fi
}

# Create a journal entry from template
jt() {
    local sanitized_name
    if ! sanitized_name=$(_sanitize_journal_name "${@}"); then
        echo "Error: Provide name for journal entry: jt [name_fragments...]" >&2
        return 1
    fi

    # Use fd and fzf to select a template from check_dirpath (excluding ARCHIVE)
    template_file=$(fd -e md -t f -t l -E ARCHIVE . "${check_dirpath}" | fzf --prompt="Select template: ")

    if [ -z "${template_file}" ]; then
        echo "No template selected" >&2
        return 1
    fi

    # Create destination path with tilda-separated pattern like new-packing-checklist
    # TODO don't use 'now'; don't rely on it existing! Instead, create a function for creating journal-compatible filenames
    dest_filepath="${journal_dirpath}/${sanitized_name}~$(now)~.md"

    # Open template in vim without writing until user saves
    _open_file_from_template_without_writing "${template_file}" "${dest_filepath}"
}

# Helper function to select journal entries via fzf
# Arguments:
#   -m: Enable multi-select mode
#   All other args: Passed as initial query to fzf
# Returns: Selected path(s) printed to stdout (one per line)
_fzf_select_journal_entry() {
    local multi_select=false
    local fzf_args=()

    # Parse flags
    if [ "${1:-}" = "-m" ]; then
        multi_select=true
        shift
    fi

    # Build fzf arguments
    # - scheme=history so that 'needle-foo' is ranked equal to 'foo-needle' when searching for 'needle'
    # - tiebreak=index so that things ranked equally are subsorted by timestamp
    fzf_args=(
        --ansi
        --delimiter=$'\t'
        --with-nth='{2}   {3}'
        --accept-nth=1
        --bind='change:top'
        --scheme=history
        --tiebreak=index
    )

    if [ "${multi_select}" = true ]; then
        fzf_args+=(-m)
    fi

    if [ "${#}" -gt 0 ]; then
        fzf_args+=(--query="${*}")
    fi

    FZF_DEFAULT_COMMAND="_fzf_journal_find_cmd" fzf "${fzf_args[@]}"
}

# Find a journal entry
jf() {
    mapfile -t output_paths < <(_fzf_select_journal_entry -m "${@}")

    if [ "${#output_paths[@]}" -gt 0 ]; then
        vim -O "${output_paths[@]}"
    fi
}

# Symlink to a journal entry
jl() {
    # First arg: path to a symlink
    # Second arg (optional): the exact name of a journal entry file
    # If it's not provided, then the user gets dumped into fzf (just like jf) to find the file
    # Finally, a symlink is created at path_to_symlink pointing to the journal entry file

    local symlink_path="${1:-}"
    local journal_entry_name="${2:-}"

    # Validate symlink path is provided
    if [ -z "${symlink_path}" ]; then
        echo "Error: First argument must be a path for the symlink" >&2
        return 1
    fi

    # Validate symlink path has .md extension
    if [[ "${symlink_path}" != *.md ]]; then
        echo "Error: Symlink path must have .md extension" >&2
        return 1
    fi

    local journal_entry_path=""

    if [ -n "${journal_entry_name}" ]; then
        # User provided a journal entry name, find it in the journal directory
        journal_entry_path="${journal_dirpath}/${journal_entry_name}"

        if [ ! -f "${journal_entry_path}" ]; then
            echo "Error: Journal entry not found at '${journal_entry_path}'" >&2
            return 1
        fi
    else
        # No journal entry provided, use fzf to select
        journal_entry_path=$(_fzf_select_journal_entry)

        if [ -z "${journal_entry_path}" ]; then
            echo "No journal entry selected" >&2
            return 1
        fi
    fi

    # Create the symlink
    ln -sf "${journal_entry_path}" "${symlink_path}"
}

jmv() {
    # Use fzf to help the user select a file
    # Let the user rename it, usign the same space-separated logic
    echo "TODO"
}

# ======================================================================================
#                                Coaching Journal
# ======================================================================================
coaching_journals_dirpath="${work_gdrive_dirpath}/private-coaching-journals"

# quick jumping to private coaching directories
cj() {
    local client_dirname
    client_dirname="$(_fzf_select_subdir "${coaching_journals_dirpath}" "${@}")" || return 1

    if [ -z "${client_dirname}" ]; then
        return 0
    fi

    cd "${coaching_journals_dirpath}/${client_dirname}"
}

# "coaching journal find"
alias cjf="jf"

# "coaching journal new"
cjn() {
    local template_filepath="${check_dirpath}/lifeops/coaching-session.md"

    if [ ! -f "${template_filepath}" ]; then
        echo "Error: Coaching session template not found at '${template_filepath}'" >&2
        return 1
    fi

    local client_dir
    client_dir="$(_fzf_select_subdir "${coaching_journals_dirpath}" "${@}")" || return 1

    if [ -z "${client_dir}" ]; then
        echo "No client selected" >&2
        return 1
    fi

    local client_dirpath="${coaching_journals_dirpath}/${client_dir}"
    local client_name="${client_dir}"

    # Create timestamp for the journal entry
    local timestamp
    timestamp="$(now)"

    # Form the journal entry filename
    local entry_filename="${client_name}-coaching~${timestamp}~coaching-journal.md"
    local entry_filepath="${journal_dirpath}/${entry_filename}"

    # Read template and inject todo contents
    local todo_filepath="${client_dirpath}/todo.md"
    local todo_contents=""
    if [ -f "${todo_filepath}" ]; then
        todo_contents="$(cat "${todo_filepath}")"
    fi

    # Create a temporary template file with injected todo
    local temp_template
    temp_template="$(mktemp)"

    # Process the template: replace <!-- inject:todo --> with todo contents
    # Pattern handles extra dashes and spaces: <!--- inject:todo ---> or <!--  inject:todo  -->
    local inject_pattern='^[[:space:]]*<!---*[[:space:]]*inject:todo[[:space:]]*-*-->[[:space:]]*$'
    while IFS= read -r line || [ -n "${line}" ]; do
        if [[ "${line}" =~ ${inject_pattern} ]]; then
            # Replace the injection marker with todo contents
            echo "${todo_contents}"
        else
            echo "${line}"
        fi
    done < "${template_filepath}" > "${temp_template}"

    # Create symlink BEFORE opening vim to guard against crashes after save
    local symlink_filename="${timestamp}_coaching.md"
    local symlink_path="${client_dirpath}/${symlink_filename}"
    ln -sf "${entry_filepath}" "${symlink_path}"

    # Open the file from the processed template
    _open_file_from_template_without_writing "${temp_template}" "${entry_filepath}"

    # Clean up temp file
    rm -f "${temp_template}"

    # If user didn't save the file, clean up the dangling symlink
    if [ ! -f "${entry_filepath}" ]; then
        rm -f "${symlink_path}"
    fi
}

cjtd() {
    local client_dirname
    client_dirname="$(_fzf_select_subdir "${coaching_journals_dirpath}" "${@}")" || return 1

    if [ -z "${client_dirname}" ]; then
        echo "No client selected" >&2
        return 1
    fi

    local client_dirpath="${coaching_journals_dirpath}/${client_dirname}"
    local todo_filepath="${client_dirpath}/todo.md"

    vim "${todo_filepath}"
}

cjcat() {
    local client_dirname
    client_dirname="$(_fzf_select_subdir "${coaching_journals_dirpath}" "${@}")" || return 1

    if [ -z "${client_dirname}" ]; then
        echo "No client selected" >&2
        return 1
    fi

    local client_dirpath="${coaching_journals_dirpath}/${client_dirname}"

    # Build concatenated output
    {
        # Add TODO section at the top
        local todo_filepath="${client_dirpath}/todo.md"
        echo "TODO"
        echo "===="
        echo ""
        if [ -f "${todo_filepath}" ]; then
            command cat "${todo_filepath}"
        fi
        echo ""
        echo ""
        echo ""

        # Find coaching journal symlinks and sort in reverse chronological order
        # Symlinks have format: YYYY-MM-DD_HH-mm-SS_coaching.md
        local first_entry=true
        find "${client_dirpath}" -maxdepth 1 -type l -name "*_coaching.md" -exec basename {} \; | \
        sort -r | \
        while read -r symlink_name; do
            if [ "${first_entry}" = true ]; then
                first_entry=false
            else
                # Add 3 blank lines between entries
                echo ""
                echo ""
                echo ""
            fi

            # Extract timestamp from filename: YYYY-MM-DD_HH-mm-SS_coaching.md -> YYYY-MM-DD HH:mm:SS
            local timestamp_raw="${symlink_name%_coaching.md}"  # Remove _coaching.md suffix
            local date_part="${timestamp_raw%_*}"               # YYYY-MM-DD
            local time_raw="${timestamp_raw##*_}"               # HH-mm-SS
            local time_part="${time_raw//-/:}"                  # HH:mm:SS
            local header_text="${date_part} ${time_part}"
            local header_underline="${header_text//?/=}"        # Replace each char with =

            echo "${header_text}"
            echo "${header_underline}"
            echo ""
            command cat "${client_dirpath}/${symlink_name}"
        done
    } | vim - -c "setlocal filetype=markdown"
}


alias todays-goals="jn todays-goals"

# ======================================================================================
#                                Overpowered Writing Tools
# ======================================================================================
alias pj="jump_post"
alias pe="edit_post"
alias pn="new_post"
alias pp="publish_post"

# ======================================================================================
#                                    Health Journal
# ======================================================================================
alias health="vim ${gref_dirpath}/health/health-journal.md"


# ======================================================================================
#                                    Musings Journal
# ======================================================================================
alias musings="vim ${gref_dirpath}/musings/one-off-musings.md"

# ======================================================================================
#                                  Portuguese Journal
# ======================================================================================
portuguese() {
    vim "${journal_dirpath}/portuguese-journal~$(now)~.md"
}

# ======================================================================================
#                             Daily/Weekly/Monthly Reflections
# ======================================================================================
day() {
    entry_filepath="${journal_dirpath}/daily-journalling~$(now)~.md"
    _open_file_from_template_without_writing "${check_dirpath}/daily-journalling.md" "${entry_filepath}"
}

get_week_plan_filepath() {
  # Ensure psup_dirpath is set
  if [ -z "${psup_dirpath}" ]; then
    echo "Error: psup_dirpath is not set."
    return 1
  fi

  # Get the date for Sunday of the current week
  # We have to use Gnu date (gdate) since Mac date doesn't have the -d option
  week_date="$(gdate -d "last sunday +0 days" +"%Y-%m-%d")"

  # Special case: if today is Sunday, use today
  if [ "$(date +%u)" -eq 7 ]; then
    week_date="$(date +"%Y-%m-%d")"
  fi

  # Construct the file path
  echo "${journal_dirpath}/week-plan~${week_date}_12-00-00.md"
}

# Weekly planning function - opens previous and current week side-by-side for review
# Uses Wednesday as threshold: Mon-Wed reviews last week vs current week, Thu-Sun reviews current week vs next week
# Creates new week files from weekly-planning.md template, sets 'w' register to 'WHY: '
week() {
    local current_day_of_week=$(date +%u)  # 1=Monday, 7=Sunday
    local template_weekly_planning_filepath="${check_dirpath}/weekly-planning.md"
    
    # Calculate which weeks are "passed" and "to come"
    # Week starts on Sunday; Sun-Fri shows current week as "to come", Saturday shows next week
    if [ "${current_day_of_week}" -eq 6 ]; then
        # Saturday: current week is "passed", next week is "to come"
        passed_week_date="$(gdate -d "last sunday" +"%Y-%m-%d")"
        to_come_week_date="$(gdate -d "next sunday" +"%Y-%m-%d")"
    elif [ "${current_day_of_week}" -eq 7 ]; then
        # Sunday: today is the start of the week
        passed_week_date="$(gdate -d "last sunday" +"%Y-%m-%d")"
        to_come_week_date="$(date +"%Y-%m-%d")"
    else
        # Mon-Fri: "last sunday" is the start of this week
        passed_week_date="$(gdate -d "last sunday -7 days" +"%Y-%m-%d")"
        to_come_week_date="$(gdate -d "last sunday" +"%Y-%m-%d")"
    fi
    
    # Create file paths
    passed_week_filepath="${journal_dirpath}/week-plan~${passed_week_date}_12-00-00.md"
    to_come_week_filepath="${journal_dirpath}/week-plan~${to_come_week_date}_12-00-00.md"
    
    # Create the "to come" week file from template if it doesn't exist
    if [ ! -f "${to_come_week_filepath}" ]; then
        cp "${template_weekly_planning_filepath}" "${to_come_week_filepath}"
    fi
    
    # Open both files side by side with 'w' register set to 'WHY: '
    if [ ! -f "${passed_week_filepath}" ]; then
        # Create temporary file with message
        temp_file=$(mktemp)
        echo "No past week reflection file exists" > "${temp_file}"
        vim -O "${temp_file}" "${to_come_week_filepath}" \
            -c "call setreg('w', 'WHY: ')" \
            -c "autocmd VimLeave * silent! call delete('${temp_file}')"
    else
        vim -O "${passed_week_filepath}" "${to_come_week_filepath}" \
            -c "call setreg('w', 'WHY: ')"
    fi
}

# Monthly planning function - opens current month (left) and next month (right) side-by-side
# Creates new month files from monthly-goals.md template in self_improvement_dirpath
month() {
    local current_month_year=$(date +%Y-%m)
    local next_month_year=$(gdate -d "next month" +%Y-%m)

    local template_month_goals_filepath="${check_dirpath}/monthly-goals.md"

    # Set up file paths
    local current_month_dirpath="${self_improvement_dirpath}/${current_month_year}"
    local current_month_filepath="${current_month_dirpath}/month-goals.md"

    local next_month_dirpath="${self_improvement_dirpath}/${next_month_year}"
    local next_month_filepath="${next_month_dirpath}/month-goals.md"

    # Create directories if they don't exist
    mkdir -p "${current_month_dirpath}"
    mkdir -p "${next_month_dirpath}"

    # Create month files from template if they don't exist
    if ! [ -f "${current_month_filepath}" ]; then
        cp "${template_month_goals_filepath}" "${current_month_filepath}"
    fi
    if ! [ -f "${next_month_filepath}" ]; then
        cp "${template_month_goals_filepath}" "${next_month_filepath}"
    fi

    # Open with current month on left, next month on right
    vim -O "${current_month_filepath}" "${next_month_filepath}"
}

# ======================================================================================
#                                    Myopia Planning
# ======================================================================================
myopia_planning_filepath="${psup_dirpath}/myopia-planning.md"
alias myopia="vim ${myopia_planning_filepath}"

# ======================================================================================
#                                    FounderOS
# ======================================================================================
founderos_dirpath="${gref_dirpath}/2025_founderos"
alias founderos="cd ${founderos_dirpath}"
alias compounding-sow="vim ${founderos_dirpath}/state-of-the-world-journal.md"
alias producthunt='open "https://www.producthunt.com/leaderboard/monthly/$(date +%Y)/$(date +%-m)"'

lifeops_dirpath="${code_dirpath}/lifeops-toolkit"
alias lifeops="cd ${lifeops_dirpath}"

alias vision="vim ${self_improvement_dirpath}/2025-10/vision-board.md"


# ======================================================================================
#                                     Claude
# ======================================================================================

# export ANTHROPIC_LOG=debug
# export ANTHROPIC_DEFAULT_HAIKU_MODEL=claude-haiku-4-5-20251001

# This is a wrapper around Claude to detect & inject 1Password secret references into Claude
claude() {
    # If stdin is being piped, use -p mode without op run
    if [ ! -t 0 ]; then
        ${BREW_PREFIX}/bin/claude -p "${@}"
    elif [ -f ".claude/secrets.env" ]; then
        # We have to add the 'script -q /dev/null' due to a Claude bug: https://github.com/anthropics/claude-code/issues/4930
        # Note: 1Password biometric auth should be done before entering tmux (see `work` function)
        op run --env-file ".claude/secrets.env" -- script -q /dev/null "${BREW_PREFIX}/bin/claude" "${@}"
    else
        ${BREW_PREFIX}/bin/claude "${@}"
    fi
}

# ======================================================================================
#                                       AgenC
# ======================================================================================
function _run_agenc_mission() {
    local agent_name="${1}"
    shift
    agenc mission new --agent "${agent_name}" --prompt "${*}"
}
alias agresearcher="_run_agenc_mission researcher"
alias agtodoist="_run_agenc_mission todoist"
